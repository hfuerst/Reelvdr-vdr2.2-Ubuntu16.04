/****************************************************************************
 * INTEL CONFIDENTIAL
 * Copyright 2008-2009 Intel Corporation.  All Rights Reserved.
 *
 * DISTRIBUTABLE AS SAMPLE SOURCE SOFTWARE
 *
 * This Distributable As Sample Source Software is subject to the terms and
 * conditions of the Intel software License Agreement for the Intel(R) Media
 * Processor Software Development Kit.
 ***************************************************************************/

/****************************************************************************
 *  Digital Home Group
 *  Intel Corporation
 *  2200 Mission College Blvd.
 *  Santa Clara, CA  95054-1549
 *  (408) 765-8080
 *  http://www.intel.com
 ***************************************************************************/

/*!  \file libdts_security_common.h
 *
 *   Common definitions used by all SEC_CRYPTO code.  Other include files needed
 *   to interface to the SEC_CRYPTO libraries #includes this file.
 *
 *   Each entry generated by the libSEC_CRYPTO_input library, and consumed by the
 *   libSEC_CRYPTO_output library, consists of some information describing the
 *   entry, AACS device keys and their corresponding node and UUV values,
 *   AACS sequence keys and their corresponding row/column information,
 *   Hcert/Hpriv, and some checksum values for integrity checking.  A portion
 *   of the data, including the AACS highly confidential keys, are encrypted
 *   using AES128-CBC.  One of the two checksums covers the entire image
 *   and allows for an entity to test the integrity of the entire package
 *   without having to decrypt any portion of it.  The other checksum is in
 *   the encrypted portion and covers the unencrypted view of the encrypted
 *   portion, which allows for an entity that decrypts the encrypted portion
 *   to confirm that it was properly decrypted.
 *
 *   Each entry is formatted as follows:
 *
 *     ALL CASES:
 *       - 4bytes big endian:    SEC_CRYPTO_entry_type_flags_t describing what is contained herein
 *       - 2bytes big endian:    order_format for device keys, or 0 if not applicable
 *       - 2bytes big endian:    order_format for host certificates, or 0 if not applicable
 *       - 8bytes big endian:    length (in bytes) of this entire data structure
 *       - 4bytes big endian:    module type (hardcoded 0x0000AACS)
 *       - 4bytes big endian:    revision number (hardcoded 0x00000002)
 *       - 4bytes big endian:    SEC_CRYPTO_MODULE_FLAG_* flags
 *       - 4bytes:               provisioning date in BCD representation yyyymmdd
 *       - 16bytes:              IV for AES-CBC encryption
 *     ================================|  BEGIN AES-CBC encrypted chain:
 *     IF SEC_CRYPTO_entry_type_flags_t includes SEC_CRYPTO_ENTRY_TYPE_FLAG_DEVICE_KEYS:
 *       - 4048bytes:            array of 253 Device Keys
 *     IF SEC_CRYPTO_entry_type_flags_t includes SEC_CRYPTO_ENTRY_TYPE_FLAG_SEQUENCE_KEYS:
 *       - 4096bytes:            array of 256 Sequence Keys with col/row data (see below)
 *     IF SEC_CRYPTO_entry_type_flags_t includes SEC_CRYPTO_ENTRY_TYPE_FLAG_HOST:
 *       - 20bytes big endian:   Hpriv (host private key)
 *     IF SEC_CRYPTO_entry_type_flags_t includes SEC_CRYPTO_ENTRY_TYPE_FLAG_ECC:
 *       - 20bytes big endian:   p (elliptic curve parameter)
 *       - 20bytes big endian:   a (elliptic curve parameter)
 *       - 20bytes big endian:   b (elliptic curve parameter)
 *       - 20bytes big endian:   Gx (elliptic curve parameter)
 *       - 20bytes big endian:   Gy (elliptic curve parameter)
 *       - 20bytes big endian:   r (elliptic curve parameter)
 *     IF acskl_entry_type_flags_t includes SEC_CRYPTO_ENTRY_TYPE_FLAG_HOST and SEC_CRYPTO_ENTRY_TYPE_FLAG_ECC:
 *       - 4bytes:               unused, filled with zeros
 *     ELSE IF acskl_entry_type_flags_t includes SEC_CRYPTO_ENTRY_TYPE_FLAG_HOST and not SEC_CRYPTO_ENTRY_TYPE_FLAG_ECC:
 *       - 12bytes:              unused, filled with zeros
 *     ELSE IF acskl_entry_type_flags_t includes SEC_CRYPTO_ENTRY_TYPE_FLAG_ECC and not SEC_CRYPTO_ENTRY_TYPE_FLAG_HOST:
 *       - 8bytes:               unused, filled with zeros
 *     IF SEC_CRYPTO_entry_type_flags_t includes SEC_CRYPTO_ENTRY_TYPE_FLAG_DEVICE_KEYS:
 *       - 1265bytes:            Umask and UVnumbers (same format as in AACS key order form)
 *       - 15bytes:              unused, filled with zeros
 *       - 16bytes:              CMAC signature generated by SOC (until then reserved zeros)
 *     ALL CASES:
 *       - 16bytes:              checksum (see below for algorithm)
 *     ================================|  END AES-CBC encrypted chain.
 *     IF SEC_CRYPTO_entry_type_flags_t includes SEC_CRYPTO_ENTRY_TYPE_FLAG_DEVICE_KEYS:
 *       - 4bytes big endian:    device node
 *       - 12bytes:              unused, filled with zeros
 *     IF SEC_CRYPTO_entry_type_flags_t includes SEC_CRYPTO_ENTRY_TYPE_FLAG_HOST:
 *       - 92bytes:              Hcert (host certificate)
 *       - 4bytes:               unused, filled with zeros
 *     ALL CASES:
 *       - 16bytes:              checksum (see below for algorithm)
 *
 *   Sequence Keys are padded from 64 bits to 128 bits each by including the corresponding
 *   row and column data as so:
 *       - 8bytes:               64-bit sequence key in same byte order as AACS key order file
 *       - 2bytes:               zero padding
 *       - 2bytes big endian:    column number
 *       - 2bytes:               zero padding
 *       - 2bytes big endian:    row number
 *
 *   Each of the two checksums covers all of the data in the entry up to the checksum itself.
 *   The checksum that is in the AES-CBC encrypted chain covers the unencrypted view of the
 *   data, while the checksum that is outside of the AES-CBC encrypted chain covers the
 *   encrypted view of the data.  The algorithm used is the Davies-Meyer hash algorithm where
 *   H0 is the XOR of all 128-bit blocks of input data along with the 128-bit big endian
 *   representation of the length of data in 128-bit blocks.
 */

#ifndef SEC_CRYPTO_COMMON_INCLUDED
#define SEC_CRYPTO_COMMON_INCLUDED


/* = = = = = = = = = = = = = = = = = = = = == = = = = = = = = = = = = = = = = = = = = */
/*!  \brief macros to determine our platform's operating system
 *
 *   Determines which operating system is on our target platform (Windows, Unix/Linux, etc.).
 *
 *   Note that this does not determine which compiler tools are used.  Do not use
 *   compiler-centric macros like _MSC_VER to derive these values as they may be
 *   incorrect (e.g. using GCC to compile Windows software).
 */
#if defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WIN32_WCE)
#define SEC_CRYPTO_OS_WIN        /*!<  #defined if the target operating system is Windows  */
#else
# if defined(__linux__) || defined(__linux) || defined(_linux) || defined(linux) || defined(__unix__) || defined(__unix) || defined(_unix) || defined(unix)
#define SEC_CRYPTO_OS_NIX        /*!<  #defined if the target operating system is Linux, Unix, or siilar  */
# endif
#endif
/* -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - */


#define SEC_CRYPTO_RSA_KEYSIZE_BITS             2048      /*!<  size of RSA public key for encrypting AES key  */
#define SEC_CRYPTO_AACS_CERT_SIZE_BYTES         92        /*!<  AAACS Hcert size bytes  */
#define SEC_CRYPTO_AACS_DEVICE_KEYS_PER_SET     253       /*!<  number of AACS Device Keys per set  */
#define SEC_CRYPTO_AACS_SEQUENCE_KEYS_PER_SET   256       /*!<  number of AACS Sequence Keys per set  */
#define SEC_CRYPTO_SHA1_SIZE_BYTES              20        /*!<  SHA1 size bytes  */


#define SEC_CRYPTO_FALSE              (0!=0)
#define SEC_CRYPTO_TRUE               (0==0)
#define SEC_CRYPTO_NULL               ((void *)0)


#ifdef _MSC_VER
#define SEC_CRYPTO_DECL_INLINE   static __inline
#else
#define SEC_CRYPTO_DECL_INLINE   static inline
#endif


/* = = = = = = = = = = = = = = = = = = = = == = = = = = = = = = = = = = = = = = = = = */
/*!  \brief return status codes
 *
 *   Return status codes for various SEC_CRYPTO functions.  The status can be checked with
 *   SEC_CRYPTO_STATUS_IS_OK() and SEC_CRYPTO_STATUS_IS_FAILURE() macros to test for success or
 *   failure.
 */
typedef enum
  {
    SEC_CRYPTO_STATUS_OK = 1, 						/*!<  generic success  */
    SEC_CRYPTO_STATUS_FAILED = 1000,				/*!<  generic failure  */
	SEC_CRYPTO_STATUS_INVALID_PARAMETER = 1001,		/*!<  Invalid function parameter failure  */
    SEC_CRYPTO_STATUS_NOT_USED 						/*!<  this status is not used  */
  }                               sec_crypto_status_t;
/* -     -     -     -     -     -     -     -  -     -     -     -     -     -     - */
/* = = = = = = = = = = = = = = = = = = = = == = = = = = = = = = = = = = = = = = = = = */
/*!  \brief check for successful status
 *
 *   Given an sec_crypto_status_t, this macro returns logical true if and only if the status
 *   is considered "successful".
 *
 *     @param[in] s                              sec_crypto_status_t to interpret
 *     @return  logical true if and only if the status is considered "successful"
 */
#define SEC_CRYPTO_STATUS_IS_OK(s)         ((s)==SEC_CRYPTO_STATUS_OK)
/* -     -     -     -     -     -     -     -  -     -     -     -     -     -     - */
/* = = = = = = = = = = = = = = = = = = = = == = = = = = = = = = = = = = = = = = = = = */
/*!  \brief check for failed status
 *
 *   Given an sec_crypto_status_t, this macro returns logical true if and only if the status
 *   is considered "failed".
 *
 *     @param[in] s                              sec_crypto_status_t to interpret
 *     @return  logical true if and only if the status is considered "failed"
 */
#define SEC_CRYPTO_STATUS_IS_FAILURE(s)    ((s)!=SEC_CRYPTO_STATUS_OK)
/* -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - */


/* = = = = = = = = = = = = = = = = = = = = == = = = = = = = = = = = = = = = = = = = = */
/*!  \brief portable sized integer declarations
 *
 *   Various typedefs and #defines to support 8-bit, 16-bit, 32-bit, and 64-bit integers,
 *   both signed and unsigned, across various platforms.
 *
 *   The following typedefs are available:
 *     - SEC_CRYPTO_i8_t         - signed 8-bit integer
 *     - SEC_CRYPTO_u8_t         - unsigned 8-bit integer
 *     - SEC_CRYPTO_i16_t        - signed 16-bit integer
 *     - SEC_CRYPTO_u16_t        - unsigned 16-bit integer
 *     - SEC_CRYPTO_i32_t        - signed 32-bit integer
 *     - SEC_CRYPTO_u32_t        - unsigned 32-bit integer
 *     - SEC_CRYPTO_i64_t        - signed 64-bit integer
 *     - SEC_CRYPTO_u64_t        - unsigned 64-bit integer
 *
 *   The following macros are available to define integer constants.  For example,
 *   SEC_CRYPTO_U64(0x123456789abcdef0) can be used to specify a 64-bit unsigned literal.
 *     - SEC_CRYPTO_I8(n)        - signed 8-bit integer
 *     - SEC_CRYPTO_U8(n)        - unsigned 8-bit integer
 *     - SEC_CRYPTO_I16(n)       - signed 16-bit integer
 *     - SEC_CRYPTO_U16(n)       - unsigned 16-bit integer
 *     - SEC_CRYPTO_I32(n)       - signed 32-bit integer
 *     - SEC_CRYPTO_U32(n)       - unsigned 32-bit integer
 *     - SEC_CRYPTO_I64(n)       - signed 64-bit integer
 *     - SEC_CRYPTO_U64(n)       - unsigned 64-bit integer
 */
#if defined(__INTEL_COMPILER) || defined(_MSC_VER) || defined(__BORLANDC__) || defined(__WATCOMC__)
typedef signed __int8             sec_crypto_i8_t;
typedef unsigned __int8           sec_crypto_u8_t;
typedef signed __int16            sec_crypto_i16_t;
typedef unsigned __int16          sec_crypto_u16_t;
typedef signed __int32            sec_crypto_i32_t;
typedef unsigned __int32          sec_crypto_u32_t;
typedef signed __int64            sec_crypto_i64_t;
typedef unsigned __int64          sec_crypto_u64_t;
#define SEC_CRYPTO_I8(n)    ((sec_crypto_i8_t)n)
#define SEC_CRYPTO_U8(n)    ((sec_crypto_u8_t)n##U)
#define SEC_CRYPTO_I16(n)   ((sec_crypto_i16_t)n)
#define SEC_CRYPTO_U16(n)   ((sec_crypto_u16_t)n##U)
#define SEC_CRYPTO_I32(n)   (n##i32)
#define SEC_CRYPTO_U32(n)   (n##ui32)
#define SEC_CRYPTO_I64(n)   (n##i64)
#define SEC_CRYPTO_U64(n)   (n##ui64)
#define SEC_CRYPTO_I8_DEFINED
#define SEC_CRYPTO_U8_DEFINED
#define SEC_CRYPTO_I16_DEFINED
#define SEC_CRYPTO_U16_DEFINED
#define SEC_CRYPTO_I32_DEFINED
#define SEC_CRYPTO_U32_DEFINED
#define SEC_CRYPTO_I64_DEFINED
#define SEC_CRYPTO_U64_DEFINED
#elif defined(__GNUC__)
# if defined(__SCHAR_MAX__) && __SCHAR_MAX__==127
typedef signed char               sec_crypto_i8_t;
typedef unsigned char             sec_crypto_u8_t;
#define SEC_CRYPTO_I8_DEFINED
#define SEC_CRYPTO_U8_DEFINED
# endif
# if defined(__SHRT_MAX__) && __SHRT_MAX__==32767LL
typedef signed short              sec_crypto_i16_t;
typedef unsigned short            sec_crypto_u16_t;
#define SEC_CRYPTO_I16_DEFINED
#define SEC_CRYPTO_U16_DEFINED
# elif defined(__INT_MAX__) && __INT_MAX__==32767LL
typedef signed int                sec_crypto_i16_t;
typedef unsigned int              sec_crypto_u16_t;
#define SEC_CRYPTO_I16_DEFINED
#define SEC_CRYPTO_U16_DEFINED
# elif defined(__WCHAR_MAX__) && (__WCHAR_MAX__==32767LL || __WCHAR_MAX__==65535ULL)
typedef signed wchar_t            sec_crypto_i16_t;
typedef unsigned wchar_t          sec_crypto_u16_t;
#define SEC_CRYPTO_I16_DEFINED
#define SEC_CRYPTO_U16_DEFINED
# elif defined(__LONG_MAX__) && __LONG_MAX__==32767LL
typedef signed long               sec_crypto_i16_t;
typedef unsigned long             sec_crypto_u16_t;
#define SEC_CRYPTO_I16_DEFINED
#define SEC_CRYPTO_U16_DEFINED
# endif
# if defined(__SHRT_MAX__) && __SHRT_MAX__==2147483647LL
typedef signed short              sec_crypto_i32_t;
typedef unsigned short            sec_crypto_u32_t;
#define SEC_CRYPTO_I32_DEFINED
#define SEC_CRYPTO_U32_DEFINED
# elif defined(__INT_MAX__) && __INT_MAX__==2147483647LL
typedef signed int                sec_crypto_i32_t;
typedef unsigned int              sec_crypto_u32_t;
#define SEC_CRYPTO_I32_DEFINED
#define SEC_CRYPTO_U32_DEFINED
# elif defined(__WCHAR_MAX__) && (__WCHAR_MAX__==2147483647LL || __WCHAR_MAX__==4294967295ULL)
typedef signed wchar_t            sec_crypto_i32_t;
typedef unsigned wchar_t          sec_crypto_u32_t;
#define SEC_CRYPTO_I32_DEFINED
#define SEC_CRYPTO_U32_DEFINED
# elif defined(__LONG_MAX__) && __LONG_MAX__==2147483647LL
typedef signed long               sec_crypto_i32_t;
typedef unsigned long             sec_crypto_u32_t;
#define SEC_CRYPTO_I32_DEFINED
#define SEC_CRYPTO_U32_DEFINED
# elif defined(__LONG_LONG_MAX__) && __LONG_LONG_MAX__==2147483647LL
typedef signed long long          sec_crypto_i32_t;
typedef unsigned long long        sec_crypto_u32_t;
#define SEC_CRYPTO_I32_DEFINED
#define SEC_CRYPTO_U32_DEFINED
# endif
# if defined(__SHRT_MAX__) && __SHRT_MAX__==9223372036854775807LL
typedef signed short              sec_crypto_i64_t;
typedef unsigned short            sec_crypto_u64_t;
#define SEC_CRYPTO_I64_DEFINED
#define SEC_CRYPTO_U64_DEFINED
# elif defined(__INT_MAX__) && __INT_MAX__==9223372036854775807LL
typedef signed int                sec_crypto_i64_t;
typedef unsigned int              sec_crypto_u64_t;
#define SEC_CRYPTO_I64_DEFINED
#define SEC_CRYPTO_U64_DEFINED
# elif defined(__WCHAR_MAX__) && (__WCHAR_MAX__==9223372036854775807LL || __WCHAR_MAX__==18446744073709551615ULL)
typedef signed wchar_t            sec_crypto_i64_t;
typedef unsigned wchar_t          sec_crypto_u64_t;
#define SEC_CRYPTO_I64_DEFINED
#define SEC_CRYPTO_U64_DEFINED
# elif defined(__LONG_MAX__) && __LONG_MAX__==9223372036854775807LL
typedef signed long               sec_crypto_i64_t;
typedef unsigned long             sec_crypto_u64_t;
#define SEC_CRYPTO_I64_DEFINED
#define SEC_CRYPTO_U64_DEFINED
# elif defined(__LONG_LONG_MAX__) && __LONG_LONG_MAX__==9223372036854775807LL
typedef signed long long          sec_crypto_i64_t;
typedef unsigned long long        sec_crypto_u64_t;
#define SEC_CRYPTO_I64_DEFINED
#define SEC_CRYPTO_U64_DEFINED
# endif
#define SEC_CRYPTO_I8(n)    ((sec_crypto_i8_t)(n ## LL))
#define SEC_CRYPTO_U8(n)    ((sec_crypto_u8_t)(n ## ULL))
#define SEC_CRYPTO_I16(n)   ((sec_crypto_i16_t)(n ## LL))
#define SEC_CRYPTO_U16(n)   ((sec_crypto_u16_t)(n ## ULL))
#define SEC_CRYPTO_I32(n)   ((sec_crypto_i32_t)(n ## LL))
#define SEC_CRYPTO_U32(n)   ((sec_crypto_u32_t)(n ## ULL))
#define SEC_CRYPTO_I64(n)   ((sec_crypto_i64_t)(n ## LL))
#define SEC_CRYPTO_U64(n)   ((sec_crypto_u64_t)(n ## ULL))
#endif  /*  else elif defined(__INTEL_COMPILER) || defined(_MSC_VER) || defined(__BORLANDC__) || defined(__WATCOMC__)  */
#if !defined(SEC_CRYPTO_I8_DEFINED) || !defined(SEC_CRYPTO_U8_DEFINED) || !defined(SEC_CRYPTO_I16_DEFINED) || !defined(SEC_CRYPTO_U16_DEFINED) || !defined(SEC_CRYPTO_I32_DEFINED) || !defined(SEC_CRYPTO_U32_DEFINED) || !defined(SEC_CRYPTO_U64_DEFINED) || !defined(SEC_CRYPTO_U64_DEFINED)
# if defined(__STDC_VERSION__) && __STDC_VERSION__>=199901L  /*  check for C99  */
#include <inttypes.h>
#  if !defined(SEC_CRYPTO_I8_DEFINED)
typedef int8_t                    sec_crypto_i8_t;
#define SEC_CRYPTO_I8_DEFINED
#  endif
#  if !defined(SEC_CRYPTO_U8_DEFINED)
typedef uint8_t                   sec_crypto_u8_t;
#define SEC_CRYPTO_U8_DEFINED
#  endif
#  if !defined(SEC_CRYPTO_I16_DEFINED)
typedef int16_t                   sec_crypto_i16_t;
#define SEC_CRYPTO_I16_DEFINED
#  endif
#  if !defined(SEC_CRYPTO_U16_DEFINED)
typedef uint16_t                  sec_crypto_u16_t;
#define SEC_CRYPTO_U16_DEFINED
#  endif
#  if !defined(SEC_CRYPTO_I32_DEFINED)
typedef int32_t                   sec_crypto_i32_t;
#define SEC_CRYPTO_I32_DEFINED
#  endif
#  if !defined(SEC_CRYPTO_U32_DEFINED)
typedef uint32_t                  sec_crypto_u32_t;
#define SEC_CRYPTO_U32_DEFINED
#  endif
#  if !defined(SEC_CRYPTO_I64_DEFINED)
typedef int64_t                   sec_crypto_i64_t;
#define SEC_CRYPTO_I64_DEFINED
#  endif
#  if !defined(SEC_CRYPTO_U64_DEFINED)
typedef uint64_t                  sec_crypto_u64_t;
#define SEC_CRYPTO_U64_DEFINED
#  endif
# endif  /*  defined(__STDC_VERSION__) && __STDC_VERSION__>=199901L  */
#endif  /*  !defined(SEC_CRYPTO_I8_DEFINED) || !defined(SEC_CRYPTO_U8_DEFINED) || !defined(SEC_CRYPTO_I16_DEFINED) || !defined(SEC_CRYPTO_U16_DEFINED) || !defined(SEC_CRYPTO_I32_DEFINED) || !defined(SEC_CRYPTO_U32_DEFINED) || !defined(SEC_CRYPTO_U64_DEFINED) || !defined(SEC_CRYPTO_U64_DEFINED)  */
#if !defined(SEC_CRYPTO_I8_DEFINED) || !defined(SEC_CRYPTO_U8_DEFINED) || !defined(SEC_CRYPTO_I16_DEFINED) || !defined(SEC_CRYPTO_U16_DEFINED) || !defined(SEC_CRYPTO_I32_DEFINED) || !defined(SEC_CRYPTO_U32_DEFINED) || !defined(SEC_CRYPTO_U64_DEFINED) || !defined(SEC_CRYPTO_U64_DEFINED)
# if defined(__KERNEL__) || defined(LINUX_KERNEL_VERSION)
#include <asm/types.h>
#  if !defined(SEC_CRYPTO_I8_DEFINED)
typedef __s8                      sec_crypto_i8_t;
#define SEC_CRYPTO_I8_DEFINED
#  endif
#  if !defined(SEC_CRYPTO_U8_DEFINED)
typedef __u8                      sec_crypto_u8_t;
#define SEC_CRYPTO_U8_DEFINED
#  endif
#  if !defined(SEC_CRYPTO_I16_DEFINED)
typedef __s16                     sec_crypto_i16_t;
#define SEC_CRYPTO_I16_DEFINED
#  endif
#  if !defined(SEC_CRYPTO_U16_DEFINED)
typedef __u16                     sec_crypto_u16_t;
#define SEC_CRYPTO_U16_DEFINED
#  endif
#  if !defined(SEC_CRYPTO_I32_DEFINED)
typedef __s32                     sec_crypto_i32_t;
#define SEC_CRYPTO_I32_DEFINED
#  endif
#  if !defined(SEC_CRYPTO_U32_DEFINED)
typedef __u32                     sec_crypto_u32_t;
#define SEC_CRYPTO_U32_DEFINED
#  endif
#  if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#   if !defined(SEC_CRYPTO_I64_DEFINED)
typedef __s64                     sec_crypto_i64_t;
#define SEC_CRYPTO_I64_DEFINED
#   endif
#   if !defined(SEC_CRYPTO_U64_DEFINED)
typedef __u64                     sec_crypto_u64_t;
#define SEC_CRYPTO_U64_DEFINED
#   endif
#  endif  /*  defined(__GNUC__) && !defined(__STRICT_ANSI__)  */
# endif  /*  defined(__KERNEL__) || defined(LINUX_KERNEL_VERSION)  */
#endif  /*  !defined(SEC_CRYPTO_I8_DEFINED) || !defined(SEC_CRYPTO_U8_DEFINED) || !defined(SEC_CRYPTO_I16_DEFINED) || !defined(SEC_CRYPTO_U16_DEFINED) || !defined(SEC_CRYPTO_I32_DEFINED) || !defined(SEC_CRYPTO_U32_DEFINED) || !defined(SEC_CRYPTO_U64_DEFINED) || !defined(SEC_CRYPTO_U64_DEFINED)  */
#if !defined(SEC_CRYPTO_I8_DEFINED)
#error  unable to define signed 8-bit integer type
#endif
#if !defined(SEC_CRYPTO_U8_DEFINED)
#error  unable to define unsigned 8-bit integer type
#endif
#if !defined(SEC_CRYPTO_I16_DEFINED)
#error  unable to define signed 16-bit integer type
#endif
#if !defined(SEC_CRYPTO_U16_DEFINED)
#error  unable to define unsigned 16-bit integer type
#endif
#if !defined(SEC_CRYPTO_I32_DEFINED)
#error  unable to define signed 32-bit integer type
#endif
#if !defined(SEC_CRYPTO_U32_DEFINED)
#error  unable to define unsigned 32-bit integer type
#endif
#if !defined(SEC_CRYPTO_I64_DEFINED)
#error  unable to define signed 64-bit integer type
#endif
#if !defined(SEC_CRYPTO_U64_DEFINED)
#error  unable to define unsigned 64-bit integer type
#endif
/* -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - */

/* = = = = = = = = = = = = = = = = = = = = == = = = = = = = = = = = = = = = = = = = = */
/*!  \brief endianness determination
 *
 *   We must define one of the following macros to define the endianness of our platform.
 *   If they were not already defined, then define one here as appropriate so our code
 *   can properly handle byte swapping.
 *
 *     - SEC_CRYPTO_OPTION_LITTLE_ENDIAN   - for little endian platforms
 *     - SEC_CRYPTO_OPTION_BIG_ENDIAN      - for big endian platforms
 */
#if !defined(SEC_CRYPTO_OPTION_BIG_ENDIAN) &&  !defined(SEC_CRYPTO_OPTION_LITTLE_ENDIAN)
#define SEC_CRYPTO_OPTION_LITTLE_ENDIAN
#endif
/* -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - */

/* = = = = = = = = = = = = = = = = = = = = == = = = = = = = = = = = = = = = = = = = = */
/*!  \brief endianness transformations
 *
 *   Where integers must be specifically in little-endian, or in big-endian representation,
 *   these macros are used to provide the appropriate byte-swapping, as needed.  The
 *   endianness of the platform is determined by whether or not SEC_CRYPTO_OPTION_BIG_ENDIAN
 *   or SEC_CRYPTO_OPTION_LITTLE_ENDIAN is #defined.  For example, SEC_CRYPTO_U32_BE(my_value)
 *   will return the value of my_value byte-swapped on little-endian platforms and not
 *   byte-swapped on big-endian platforms.
 *
 *   The following macros are available to define integer constants.  For example,
 *   SEC_CRYPTO_U64(0x123456789abcdef0) can be used to specify a 64-bit unsigned literal.
 *     - SEC_CRYPTO_U16_BE(n)    - unsigned 16-bit integer: byte-swap if little-endian platform
 *     - SEC_CRYPTO_U16_LE(n)    - unsigned 16-bit integer: byte-swap if big-endian platform
 *     - SEC_CRYPTO_U32_BE(n)    - unsigned 32-bit integer: byte-swap if little-endian platform
 *     - SEC_CRYPTO_U32_LE(n)    - unsigned 32-bit integer: byte-swap if big-endian platform
 *     - SEC_CRYPTO_U64_BE(n)    - unsigned 64-bit integer: byte-swap if little-endian platform
 *     - SEC_CRYPTO_U64_LE(n)    - unsigned 64-bit integer: byte-swap if big-endian platform
 */
/*  TODO:  make use of intrinsic bit-rotation instructions on MSVC and GCC, or inline assembler, to speed these byte-order-swappings up  */
#if defined(SEC_CRYPTO_OPTION_BIG_ENDIAN)
#define SEC_CRYPTO_U16_BE(n)     (sec_crypto_u16_t)(n)
#define SEC_CRYPTO_U16_LE(n)     ((sec_crypto_u16_t)((((n)&SEC_CRYPTO_U16(0xFF))<<8u)|((sec_crypto_u16_t)((n)&SEC_CRYPTO_U32(0xFF00))>>8u)))
#define SEC_CRYPTO_U32_BE(n)     (sec_crypto_u32_t)(n)
#define SEC_CRYPTO_U32_LE(n)     (((sec_crypto_u32_t)((n)&SEC_CRYPTO_U32(0xFF))<<24u)|((sec_crypto_u32_t)((n)&SEC_CRYPTO_U32(0xFF00))<<8u)|((sec_crypto_u32_t)((n)&SEC_CRYPTO_U32(0xFF0000))>>8u)|((sec_crypto_u32_t)((n)&SEC_CRYPTO_U32(0xFF000000))>>24u))
#define SEC_CRYPTO_U64_BE(n)     (sec_crypto_u64_t)(n)
#define SEC_CRYPTO_U64_LE(n)     ((((sec_crypto_u64_t)SEC_CRYPTO_U32_LE((sec_crypto_u32_t)((n)&SEC_CRYPTO_U64(0xFFFFFFFF))))<<SEC_CRYPTO_U64(32))|SEC_CRYPTO_U32_LE((sec_crypto_u32_t)((n)>>SEC_CRYPTO_U64(32))))
#else
#define SEC_CRYPTO_U16_BE(n)     ((sec_crypto_u16_t)((((n)&SEC_CRYPTO_U16(0xFF))<<8u)|((sec_crypto_u16_t)((n)&SEC_CRYPTO_U32(0xFF00))>>8u)))
#define SEC_CRYPTO_U16_LE(n)     (sec_crypto_u16_t)(n)
#define SEC_CRYPTO_U32_BE(n)     (((sec_crypto_u32_t)((n)&SEC_CRYPTO_U32(0xFF))<<24u)|((sec_crypto_u32_t)((n)&SEC_CRYPTO_U32(0xFF00))<<8u)|((sec_crypto_u32_t)((n)&SEC_CRYPTO_U32(0xFF0000))>>8u)|((sec_crypto_u32_t)((n)&SEC_CRYPTO_U32(0xFF000000))>>24u))
#define SEC_CRYPTO_U32_LE(n)     (sec_crypto_u32_t)(n)
#define SEC_CRYPTO_U64_BE(n)     ( (((sec_crypto_u64_t)SEC_CRYPTO_U32_BE((sec_crypto_u32_t)((n)&SEC_CRYPTO_U64(0xFFFFFFFF))))<<SEC_CRYPTO_U64(32)) | SEC_CRYPTO_U32_BE((sec_crypto_u32_t)((n)>>SEC_CRYPTO_U64(32))) )
#define SEC_CRYPTO_U64_LE(n)       (sec_crypto_u64_t)(n)
#endif
/* -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - */


/* = = = = = = = = = = = = = = = = = = = = == = = = = = = = = = = = = = = = = = = = = */
/*!  \brief 128-bit data block
 *
 *   Defines a 128-bit (16-byte) block of arbitrary data.  This structure is used for
 *   things like AES cipher blocks, keys, iv, etc.
 */
typedef union
  {
    sec_crypto_u8_t         u8[16];        /*!<  interpret 128 bits as 16-length array of SEC_CRYPTO_u8_t  */
    sec_crypto_u16_t        u16[8];        /*!<  interpret 128 bits as 8-length array of SEC_CRYPTO_u16_t  */
    sec_crypto_u32_t        u32[4];        /*!<  interpret 128 bits as 4-length array of SEC_CRYPTO_u32_t  */
    sec_crypto_u64_t        u64[2];        /*!<  interpret 128 bits as 2-length array of SEC_CRYPTO_u64_t  */
  }                               sec_crypto_128bits_t;
/* -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - */


/* = = = = = = = = = = = = = = = = = = = = == = = = = = = = = = = = = = = = = = = = = */
/*!  \brief 160-bit data block
 *
 *   Defines a 160-bit (20-byte) block of arbitrary data.  This structure is used for
 *   things like SHA-1 hash, ECC 160-bit parameters, etc.
 */
typedef union
  {
    sec_crypto_u8_t         u8[20];        /*!<  interpret 160 bits as 20-length array of SEC_CRYPTO_u8_t  */
    sec_crypto_u16_t        u16[10];       /*!<  interpret 160 bits as 10-length array of SEC_CRYPTO_u16_t  */
    sec_crypto_u32_t        u32[5];        /*!<  interpret 160 bits as 5-length array of SEC_CRYPTO_u32_t  */
    sec_crypto_u64_t        u64[2];        /*!<  interpret first 128 bits as 2-length array of SEC_CRYPTO_u64_t  */
  }                               sec_crypto_160bits_t;
/* -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - */


/* = = = = = = = = = = = = = = = = = = = = == = = = = = = = = = = = = = = = = = = = = */
/*!  \brief encrypted AES key structure
 *
 *   This structure holds an encrypted AES key.
 */
typedef struct
  {
    sec_crypto_u8_t                   data[(SEC_CRYPTO_RSA_KEYSIZE_BITS+7)/8];
  }                               sec_crypto_encrypted_key_t;
/* -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - */


#ifdef __cplusplus
extern "C" {
# if 0
}  /*  hack to make things less confusing for some editors  */
# endif
#endif
/*-v-v-v-v-v-v-v-v-v-v-v-v-v-v-v-v-v-v-v-v-vv-v-v-v-v-v-v-v-v-v-v-v-v-v-v-v-v-v-v-v-v-*/
/*                        ALL EXTERNAL C SYMBOLS GO BELOW HERE                        */
/*------------------------------------------------------------------------------------*/


/*------------------------------------------------------------------------------------*/
/*                        ALL EXTERNAL C SYMBOLS GO ABOVE HERE                        */
/*-^-^-^-^-^-^-^-^-^-^-^-^-^-^-^-^-^-^-^-^-^^-^-^-^-^-^-^-^-^-^-^-^-^-^-^-^-^-^-^-^-^-*/
#ifdef __cplusplus
# if 0
{  /*  hack to make things less confusing for some editors  */
# endif
}
#endif

#endif  /*  ndef SEC_CRYPTO_COMMON_INCLUDED  */

