/*

  This file is provided under a dual BSD/GPLv2 license.  When using or
  redistributing this file, you may do so under either license.

  GPL LICENSE SUMMARY

  Copyright(c) 2007-2011 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  Intel Corporation
  2200 Mission College Blvd.
  Santa Clara, CA 97052

  BSD LICENSE

  Copyright(c) 2007-2011 Intel Corporation. All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

#ifndef __VIDDEC_HAL_FB_MGR_H__
#define __VIDDEC_HAL_FB_MGR_H__

/** The purpose of this API is to implement a basic frame buffer manager
 *  for viddec frame buffers.
 *
 *  Background: The ISMD frame buffer type provides a general interface
 *  for SMD frame buffers. The attributes specified in this data structure
 *  are centered around attributes that are common for all elements in the
 *  video pipeline.
 *
 *  The common SMD frame buffer type is missing several very important
 *  attributes for the video decoder. For example, the SMD frame buffer
 *  type does not store the frame type (I, P, or B). This is not important
 *  for downstream elements such as a post processor, but it is important
 *  for internal operations such as frame mask, where the decoder will
 *  not want to decode frames of a certain type.
 *
 *  This API defines a video decoder frame buffer type that is derived
 *  from the SMD frame buffer type, but includes decoder specific attributes
 *  such as errors in frames, frame type, etc.
 *
 *  The \ref viddec_hal_frame_buffer_t is a data type that describes the
 *  frame data generated by the decode process.
 *
 *  NOTE: This logic is not tied to a specific HW implementation. Thus,
 *  it's inclusion in the HAL is suspect. I have decided to include it in the
 *  HAL as a common service provided by the HAL for a couple of reasons:
 *
 *  1) To simplify multistream, we want each stream to have its own pool
 *  of frame buffers, rather than provide a global pool of buffers.
 *  This is probably a style decision, but it seems to be clearer to me. In any
 *  case, to achieve this we create an array of frame buffers in the HAL
 *  context. This creates some coupling between the resource we are managing
 *  (the pool of frame buffers) and the HAL.
 *
 *  2) There is already a natural flow between the driver and the HAL where
 *  the driver accesses services provided by the HAL. So it makes sense
 *  to continue this paradigm here, rather than, for example, have the HAL
 *  call the driver to allocate a frame buffer.
 *
 *  So I am thinking of the HAL as a HAL on steroids (HAL+). It includes
 *  the HW abstraction plus a set of services that are related to HW events.
 *  We can revisit this restructuring at a later date.
 */
#ifdef __cplusplus
extern "C" {
#endif

#include "ismd_global_defs.h" /* pull in ismd_buffer_handle_t */

/* One work load buffer of 32k is splitted into three 10k 
 * user data buffers for three work loads 
 * Each wkld has 10k user data buffer which is copied on to 
 * 1k ismd buffers sent through user data port 
 * So maximum possible number of 1k user data buffers per frame */
#define VIDDEC_MAX_USERDATA_BUFS_PER_FRAME 10

/* used for 3:2 pulldown by all codecs */
typedef enum
{
   NO_FRAME_DOUBLING       = 0,
   H264_FRAME_DOUBLING     = 1,
   H264_FRAME_TRIPLING     = 2,
   /* Top field first and Bottom field first will be 
   used for storing 3:2 pulldown info by MPEG2 and VC1 */
   TOP_FIELD_FIRST         = 3,
   BOTTOM_FIELD_FIRST      = 4
} codec_repeat_frame_t;

/* used for H264 pan scan propagation */
typedef struct h264_pan_scan_data
{
   unsigned int repetition_period;
   int          rect_id;
   bool         cancel_flag;
} h264_pan_scan_data_t;

/* User data structure holding 1k user data buffer info. */
typedef struct ud_buf_str
{
   ismd_buffer_handle_t id;       /* handle of the 1k user data buffer*/
   unsigned int ud_item_type;     /* Item type of the user data copied into this buffer */
   bool is_written;     /* Indicates whether this buffer is written into user data queue or not */

}ud_buf_str_t;
/** viddec_hal_frame_buffer_t extends SMD frame attributes to include video 
    decoder specific attributes such as frame type, error information, etc. 
 */
typedef struct viddec_hal_frame_buffer
{
   ismd_buffer_handle_t reg_fb; /*regular fb for normal playback*/
   ismd_buffer_handle_t pip_fb; /*pip fb used if downscaling is enabled*/
   ismd_buffer_handle_t vc1_ra_fb; /*range adjustment buffer, used only by VC1*/
   ismd_buffer_handle_t output_fb; /* This fb will be written to o/p port */
   int index; /* read only, modified only at init time */

   bool is_reg_fb_dereferenced_in_scale_mode;  /* In scale mode we dereference
                           the reg_fb when writing to display stack or display queue.
                           This flag tracks corner cases where the buffer was
                           not dereferenced and then gets released in the
                           hal_release_frame_buffer function. */
   bool is_skipped_frame; /* indicates frame was VC-1 skipped frame */

   struct viddec_hal_frame_buffer *forward_reference;
   struct viddec_hal_frame_buffer *backward_reference;

   ismd_frame_type_t type;
   ismd_viddec_output_scale_factor_t scale_factor; /*used if scaling is enabled*/

   /* WARNING: DO NOT access these attributes directly. Use:
    *
    * viddec_hal_set_frame_is_released
    * viddec_hal_get_frame_is_released
    * viddec_hal_set_frame_is_written
    * viddec_hal_get_frame_is_written
    * viddec_hal_set_frame_is_displayed
    * viddec_hal_get_frame_is_displayed
    *
    * to get and set these attributes.
    */

   bool is_released; /* this buffer is NOT needed as a reference frame */
   bool is_written; /* this buffer has been written to the output port */
   bool is_displayed; /* buffer has been been marked ready for display */

   /* End attributes that should not be accessed directly */

   /*this is a 32 bit value containing all error flags reported by the platform*/
   unsigned int error_flags;

   /*parameters used by smooth reverse*/
   bool first_frame_in_segment;  /*first frame in this data segment*/
   bool last_frame_in_segment;   /*last frame to be reversed in this data segment*/

   unsigned long frame_decode_number;
   signed int fb_hal_lock_count;

   /* This flag is set when new video sequence information is found preceding
    * this frame in the bitstream. This is important for certain video
    * decoder applications such as MPEG-2 pan-scan. The MPEG-2 standard
    * states that forward propagation of pan-scan vectors should stop after
    * a new sequence header is found.
    */
   bool new_seq_hdr_found;

   /* This is a 3:2 pulldown specific attribute and is overloaded for use by
    * all codecs. In H264, if pic timing SEI message indicates the content
    * is a frame and the frame should be doubled or tripled. This variable
    * stores the repeat count. In VC-1 this stores the repeat frame count
    * value in 3:2 pulldown for progressive sequences. In MPEG2, this variable
    * is not used.
    */
   codec_repeat_frame_t repeat_frame_cnt;

   /* This is a 3:2 pulldown specific attribute and is overloaded for use by
    * VC-1 and MPEG2. In H264, this variable is not used. In VC-1 and MPEG2, 
    * this variable is used to store top field first value.
    */
   unsigned int tff;

   /* This value is used to assure that the MPEG-2 stream polarity for this specific 
      frame remains valid in all conditions. */
   bool mpeg2_progressive_seq; 

   /*This stores h264 pan scan related information*/
   h264_pan_scan_data_t h264_ps_data;

   int view_index; /* In multi-view stream, this denotes the
                    * view index that this frame belongs to. In
                    * single stream, this defaults to 0 */
   /* 1k user data buffers info */
   ud_buf_str_t ud_bufs[VIDDEC_MAX_USERDATA_BUFS_PER_FRAME];
   unsigned int  num_ud_bufs;     /* Actual number of the user data bufs that have valid data */

   ismd_buffer_handle_t alias_fb; /* Alias fb for the right View in case of
                                     SideBySide or Top-Bottom 3D-AVC formats */
   bool is_alias_written; /* this alias buffer has been written to the 
                             output port */
   bool is_alias_displayed; /* this alias buffer has been written to the 
                               display queue */

   /* Current Stream Format (2D/3D)
    * Frame Buffer Allocation and Release mechanism differs for SBS/TB and FS
    * format will be used to determine SBS/TB/FS(3D) and 2D */
   ismd_viddec_stream_format_t format;

   /*used for mp4 redundant skip frame*/
   bool is_redundant_skipped_fb;             

   ismd_viddec_output_scale_factor_t jpeg_scale_factor; /*used if jpeg scaling is enabled*/

} viddec_hal_frame_buffer_t;

#define VIDDEC_NO_REFERENCE_FRAME NULL

#ifdef __cplusplus
}
#endif
#endif /* __VIDDEC_HAL_FB_MGR_H__*/
