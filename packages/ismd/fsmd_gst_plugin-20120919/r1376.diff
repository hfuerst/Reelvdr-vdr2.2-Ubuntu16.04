Index: ismd_gst_vidrend_sink.c
===================================================================
--- ismd_gst_vidrend_sink.c	(Revision 1373)
+++ ismd_gst_vidrend_sink.c	(Arbeitskopie)
@@ -1343,12 +1343,19 @@
   G_OBJECT_CLASS (parent_class)->dispose (object);
 }
 
+#ifndef NOT_REEL_PATCHED
+static ISmdGstVidrendSink * old_sink = NULL;
+#endif
+
 static void
 ismd_gst_vidrend_sink_finalize (GObject * object)
 {
   ISmdGstVidrendSink *sink;
 
   sink = ISMD_GST_VIDREND_SINK (object);
+#ifndef NOT_REEL_PATCHED
+  if(old_sink==sink) old_sink = NULL;
+#endif
   g_value_unset (&sink->rectangle);
   g_static_rec_mutex_free (sink->monitor_mutex);
   g_free (sink->monitor_mutex);
@@ -1507,6 +1514,12 @@
   sink->out_port = ISMD_PORT_HANDLE_INVALID;
   sink->qos_enabled = DEFAULT_ISMD_VIDEO_SINK_QOS;
   sink->flush_repeat_frame = DEFAULT_ISMD_VIDEO_SINK_FLUSH_REPEAT_FRAME;
+#ifndef NOT_REEL_PATCHED
+  sink->provided_clock = NULL;
+  //UGLY PATCH: Reuse the clock since we expect that the old instance will not be finalized
+  if(old_sink) sink->provided_clock = ismd_gst_clock_reuse(old_sink->provided_clock);
+  old_sink=sink;
+#endif
   ismd_gst_vidrend_sink_reset_qos (sink);
   g_value_init (&sink->rectangle, GST_TYPE_RECTANGLE);
   gst_value_set_rectangle (&sink->rectangle, 0, 0, 0, 0);
Index: ismd_gst_audio_sink.c
===================================================================
--- ismd_gst_audio_sink.c	(Revision 1373)
+++ ismd_gst_audio_sink.c	(Arbeitskopie)
@@ -1429,12 +1429,19 @@
   G_OBJECT_CLASS (parent_class)->dispose (object);
 }
 
+#ifndef NOT_REEL_PATCHED
+static ISmdGstAudioSink * old_sink = NULL;
+#endif
+
 static void
 ismd_gst_audio_sink_finalize (GObject * object)
 {
   ISmdGstAudioSink *sink;
 
   sink = ISMD_GST_AUDIO_SINK (object);
+#ifndef NOT_REEL_PATCHED
+  if(old_sink==sink) old_sink = NULL;
+#endif
 
   g_static_rec_mutex_free (sink->monitor_mutex);
   g_free (sink->monitor_mutex);
@@ -2591,7 +2598,6 @@
 
 #ifndef NOT_REEL_PATCHED
   //UGLY PATCH: Reuse the clock since we expect that the old instance will not be finalized
-  static ISmdGstAudioSink * old_sink=NULL;
   if(old_sink) sink->provided_clock = ismd_gst_clock_reuse(old_sink->provided_clock);
   old_sink=sink;
 #endif
Index: ismd_gst_clock.c
===================================================================
--- ismd_gst_clock.c	(Revision 1373)
+++ ismd_gst_clock.c	(Arbeitskopie)
@@ -251,6 +251,30 @@
 }
 
 #ifndef NOT_REEL_PATCHED
+void
+ismd_gst_clock_bufmon_remove_render (ISmdGstClock * clock, ismd_dev_t rend_handle) {
+  gint i;
+  gboolean ret = FALSE;
+  ismd_result_t result = ISMD_SUCCESS;
+
+  GST_OBJECT_LOCK (clock);
+  for (i = 0; i < MAX_MONITORED_DEVICES ; i++) {
+    if(ret) {
+      clock->bufmon_devices[i-1] = clock->bufmon_devices[i];
+    } else if (clock->bufmon_devices[i] == rend_handle) {
+      ret = TRUE;
+      result = ismd_bufmon_remove_renderer (clock->bufmon_handle, rend_handle);
+      if (result != ISMD_SUCCESS)
+        GST_ERROR_OBJECT (clock, "ismd_bufmon_remove_renderer failed (%d)", result);
+    }
+  }
+  if(ret) {
+    clock->bufmon_devices[MAX_MONITORED_DEVICES-1] = ISMD_DEV_HANDLE_INVALID;
+    clock->bufmon_n_devices--;
+  }
+  GST_OBJECT_UNLOCK (clock);
+}
+
 ISmdGstClock *ismd_gst_clock_reuse(ISmdGstClock * clock) {
   gint i;
   if(!clock) return NULL;
Index: ismd_gst_clock.h
===================================================================
--- ismd_gst_clock.h	(Revision 1373)
+++ ismd_gst_clock.h	(Arbeitskopie)
@@ -112,6 +112,7 @@
 void ismd_gst_clock_bufmon_add_source (ISmdGstClock * clock, ismd_dev_t source_handle);
 
 #ifndef NOT_REEL_PATCHED
+void ismd_gst_clock_bufmon_remove_render (ISmdGstClock * clock, ismd_dev_t rend_handle);
 ISmdGstClock *ismd_gst_clock_reuse(ISmdGstClock * clock);
 #endif
 
Index: ismd_gst_vidsink.c
===================================================================
--- ismd_gst_vidsink.c	(Revision 1373)
+++ ismd_gst_vidsink.c	(Arbeitskopie)
@@ -2190,12 +2190,19 @@
   G_OBJECT_CLASS (parent_class)->dispose (object);
 }
 
+#ifndef NOT_REEL_PATCHED
+  static ISmdGstVidsink * old_sink = NULL;
+#endif
+
 static void
 ismd_gst_vidsink_finalize (GObject * object)
 {
   ISmdGstVidsink *sink;
 
   sink = ISMD_GST_VIDSINK (object);
+#ifndef NOT_REEL_PATCHED
+  if(old_sink==sink) old_sink = NULL;
+#endif
   g_value_unset (&sink->rectangle);
   g_static_rec_mutex_free (sink->monitor_mutex);
   g_free (sink->monitor_mutex);
@@ -2378,7 +2385,6 @@
 #ifndef NOT_REEL_PATCHED
   sink->provided_clock = NULL;
 //UGLY PATCH: Reuse the clock since we expect that the old instance will not be finalized
-  static ISmdGstVidsink * old_sink = NULL;
   if(old_sink) sink->provided_clock = ismd_gst_clock_reuse(old_sink->provided_clock);
   old_sink=sink;
 #endif
Index: ismd_gst_element.c
===================================================================
--- ismd_gst_element.c	(Revision 1373)
+++ ismd_gst_element.c	(Arbeitskopie)
@@ -1078,6 +1078,16 @@
       GST_PAD_PREROLL_UNLOCK (GST_PAD (smd_element->sink_pad));
 
       break;
+#ifndef NOT_REEL_PATCHED
+    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+      if (klass->is_sink) {
+        if (ISMD_GST_IS_CLOCK (element->clock)) {
+          ISmdGstClock *smd_clock = ISMD_GST_CLOCK (element->clock);
+          ismd_gst_clock_bufmon_remove_render (smd_clock, smd_element->dev_handle);
+        }
+      }
+      break;
+#endif
     case GST_STATE_CHANGE_PAUSED_TO_READY:
       GST_OBJECT_LOCK (smd_element);
       smd_element->is_flushing = TRUE;
