--- device.c	(revision 15412)
+++ device.c	(revision 15413)
@@ -270,6 +282,9 @@
   int NumCamSlots = CamSlots.Count();
   int SlotPriority[NumCamSlots];
   int NumUsableSlots = 0;
+#ifdef USE_MCLI
+  bool InternalCamNeeded = false;
+#endif /* MCLI */
   if (Channel->Ca() >= CA_ENCRYPTED_MIN) {
      for (cCamSlot *CamSlot = CamSlots.First(); CamSlot; CamSlot = CamSlots.Next(CamSlot)) {
          SlotPriority[CamSlot->Index()] = MAXPRIORITY + 1; // assumes it can't be used
@@ -283,7 +298,11 @@
             }
          }
      if (!NumUsableSlots)
+#ifdef USE_MCLI
+        InternalCamNeeded = true; // no CAM is able to decrypt this channel
+#else
         return NULL; // no CAM is able to decrypt this channel
+#endif /* MCLI */
      }
 
   bool NeedsDetachReceivers = false;
@@ -299,11 +318,21 @@
              continue; // this device shall be temporarily avoided
           if (Channel->Ca() && Channel->Ca() <= CA_DVB_MAX && Channel->Ca() != device[i]->CardIndex() + 1)
              continue; // a specific card was requested, but not this one
+#ifdef USE_MCLI
+          if (InternalCamNeeded && !device[i]->HasInternalCam())
+             continue; // no CAM is able to decrypt this channel and the device uses vdr handled CAMs
+          if (NumUsableSlots && !device[i]->HasInternalCam() && !CamSlots.Get(j)->Assign(device[i], true))
+#else
           if (NumUsableSlots && !CamSlots.Get(j)->Assign(device[i], true))
+#endif /* MCLI */
              continue; // CAM slot can't be used with this device
           bool ndr;
           if (device[i]->ProvidesChannel(Channel, Priority, &ndr)) { // this device is basicly able to do the job
+#ifdef USE_MCLI
+             if (NumUsableSlots && !device[i]->HasInternalCam() && device[i]->CamSlot() && device[i]->CamSlot() != CamSlots.Get(j))
+#else
              if (NumUsableSlots && device[i]->CamSlot() && device[i]->CamSlot() != CamSlots.Get(j))
+#endif /* MCLI */
                 ndr = true; // using a different CAM slot requires detaching receivers
              // Put together an integer number that reflects the "impact" using
              // this device would have on the overall system. Each condition is represented
@@ -317,19 +346,48 @@
              imp <<= 1; imp |= device[i]->Receiving();                                                               // avoid devices that are receiving
              imp <<= 4; imp |= GetClippedNumProvidedSystems(4, device[i]) - 1;                                       // avoid cards which support multiple delivery systems
              imp <<= 1; imp |= device[i] == cTransferControl::ReceiverDevice();                                      // avoid the Transfer Mode receiver device
+#ifdef USE_LNBSHARE
+             int badPriority = device[i]->GetMaxBadPriority(Channel);
+             if (badPriority < 0 )                  // a device receiving with lower priority would need to be stopped
+             {
+                imp <<= 8; imp |= min(max(device[i]->Priority() + MAXPRIORITY, 0), 0xFF);                       // use the device with the lowest priority (+MAXPRIORITY to assure that values -99..99 can be used)
+             } else {
+                imp <<= 8; imp |= min(max(max(device[i]->Priority(), badPriority) + MAXPRIORITY, 0), 0xFF);          // use the device with the lowest priority (+MAXPRIORITY to assure that values -99..99 can be used)
+             }
+#else
              imp <<= 8; imp |= min(max(device[i]->Priority() + MAXPRIORITY, 0), 0xFF);                               // use the device with the lowest priority (+MAXPRIORITY to assure that values -99..99 can be used)
+#endif /* LNBSHARE */
+#ifdef USE_MCLI
+             imp <<= 8; imp |= min(max(((NumUsableSlots && !device[i]->HasInternalCam()) ? SlotPriority[j] : 0) + MAXPRIORITY, 0), 0xFF);              // use the CAM slot with the lowest priority (+MAXPRIORITY to assure that values -99..99 can be used)
+#else
              imp <<= 8; imp |= min(max((NumUsableSlots ? SlotPriority[j] : 0) + MAXPRIORITY, 0), 0xFF);              // use the CAM slot with the lowest priority (+MAXPRIORITY to assure that values -99..99 can be used)
+#endif /* MCLI */
              imp <<= 1; imp |= ndr;                                                                                  // avoid devices if we need to detach existing receivers
              imp <<= 1; imp |= device[i]->IsPrimaryDevice();                                                         // avoid the primary device
+#ifdef USE_LNBSHARE
+             imp |= (badPriority == -1);                                                                               // avoid cards where the actual device needs to be switched
+#endif /* LNBSHARE */
+#ifdef USE_MCLI
+             imp <<= 1; imp |= (NumUsableSlots || InternalCamNeeded) ? 0 : device[i]->HasCi();                       // avoid cards with Common Interface for FTA channels
+#else
              imp <<= 1; imp |= NumUsableSlots ? 0 : device[i]->HasCi();                                              // avoid cards with Common Interface for FTA channels
+#endif /* MCLI */
              imp <<= 1; imp |= device[i]->HasDecoder();                                                              // avoid full featured cards
+#ifdef USE_MCLI
+             imp <<= 1; imp |= (NumUsableSlots && !device[i]->HasInternalCam()) ? !ChannelCamRelations.CamDecrypt(Channel->GetChannelID(), j + 1) : 0; // prefer CAMs that are known to decrypt this channel
+#else
              imp <<= 1; imp |= NumUsableSlots ? !ChannelCamRelations.CamDecrypt(Channel->GetChannelID(), j + 1) : 0; // prefer CAMs that are known to decrypt this channel
+#endif /* MCLI */
              if (imp < Impact) {
                 // This device has less impact than any previous one, so we take it.
                 Impact = imp;
                 d = device[i];
                 NeedsDetachReceivers = ndr;
+#ifdef USE_MCLI
+                if (NumUsableSlots && !device[i]->HasInternalCam())
+#else
                 if (NumUsableSlots)
+#endif /* MCLI */
                    s = CamSlots.Get(j);
                 }
              }
@@ -728,6 +815,9 @@
      cChannel *channel;
      while ((channel = Channels.GetByNumber(n, Direction)) != NULL) {
            // try only channels which are currently available
+#ifdef USE_PINPLUGIN
+        if (cStatus::MsgChannelProtected(0, channel) == false)
+#endif /* PINPLUGIN */
            if (GetDevice(channel, 0, true))
               break;
            n = channel->Number() + Direction;
@@ -747,8 +837,53 @@
   return result;
 }
 
+#ifdef USE_LNBSHARE
+cDevice *cDevice::GetBadDevice(const cChannel *Channel)
+{
+  if(!cSource::IsSat(Channel->Source())) return NULL;  // no conflict if the new channel is not on sat
+  if(!ProvidesSource(cSource::stSat)) return NULL;     // no conflict if this device is not on sat
+  for (int i = 0; i < numDevices; i++) {
+    if (this != device[i] && device[i]->IsShareLnb(this) &&  device[i]->IsLnbConflict(Channel) ) {
+    	// there is a conflict between device[i] and 'this' if we tune this to Channel
+      if (Setup.VerboseLNBlog) {
+        isyslog("LNB %d: Device check for channel %d on device %d. LNB or DiSEq conflict with device %d", LnbNr(), Channel->Number(), this->DeviceNumber(), i);
+      }
+      return device[i];
+    }
+  }
+  if (Setup.VerboseLNBlog) { 
+    isyslog("LNB %d: Device check for for channel %d on device %d. OK", LnbNr(), Channel->Number(), this->DeviceNumber());
+  }
+  return NULL;
+}
+
+int cDevice::GetMaxBadPriority(const cChannel *Channel) const
+{                                
+  if(!cSource::IsSat(Channel->Source())) return -2;  // no conflict if the new channel is not on sat
+  if(!ProvidesSource(cSource::stSat)) return -2;     // no conflict if this device is not on sat
+
+  int maxBadPriority = -2;
+  for (int i = 0; i < numDevices; i++) {
+    if (this != device[i] && device[i]->IsShareLnb(this) && device[i]->IsLnbConflict(Channel) ) {
+    	// there is a conflict between device[i] and 'this' if we tune this to Channel
+      if (device[i]->Receiving() && device[i]->Priority() > maxBadPriority) maxBadPriority = device[i]->Priority();
+      if (i == ActualDevice()->CardIndex() && maxBadPriority < -1 ) maxBadPriority = -1;
+    }
+  }
+
+  if (Setup.VerboseLNBlog) { 
+    isyslog("LNB %d: Request for channel %d on device %d. MaxBadPriority is %d", LnbNr(), Channel->Number(), this->DeviceNumber(), maxBadPriority);
+  }
+  return maxBadPriority;
+}
+#endif /* LNBSHARE */
 eSetChannelResult cDevice::SetChannel(const cChannel *Channel, bool LiveView)
 {
+#ifdef USE_PINPLUGIN
+  if (LiveView && cStatus::MsgChannelProtected(this, Channel) == true)
+     return scrNotAvailable;
+#endif /* PINPLUGIN */
+
   if (LiveView) {
      StopReplay();
      DELETENULL(liveSubtitle);
@@ -1081,6 +1222,10 @@
      int LanguagePreference = INT_MAX; // higher than the maximum possible value
      for (int i = ttSubtitleFirst; i <= ttSubtitleLast; i++) {
          const tTrackId *TrackId = GetTrack(eTrackType(i));
+#ifdef USE_LIEMIEXT
+         if (TrackId && TrackId->id && (I18nIsPreferredLanguage(Setup.SubtitleLanguages, TrackId->language, LanguagePreference) ||
+             ((i == ttSubtitleFirst + 8) && !(*TrackId->language) && (LanguagePreference == INT_MAX))))
+#endif /* LIEMIEXT */
          if (TrackId && TrackId->id && I18nIsPreferredLanguage(Setup.SubtitleLanguages, TrackId->language, LanguagePreference))
             PreferredTrack = eTrackType(i);
          }
