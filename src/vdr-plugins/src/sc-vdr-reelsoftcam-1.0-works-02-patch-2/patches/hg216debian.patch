diff -Naur sc-orgnl/cam.c sc/cam.c
--- sc-orgnl/cam.c	2014-04-29 15:09:34.165738565 +0200
+++ sc/cam.c	2014-04-29 15:11:14.005734922 +0200
@@ -1841,7 +1841,7 @@
   cScCamSlot(cCam *Cam, const char *DevId, int Slot);
   void Process(const unsigned char *data, int len);
   eModuleStatus Status(void);
-  bool Reset(bool log=true);
+  bool ResetSlot(bool log=true);
   cCiFrame *Frame(void) { return &frame; }
   };
 
@@ -1853,7 +1853,7 @@
   cam=Cam; devId=DevId; slot=Slot;
   version=0; caids[0]=0; doReply=false; lastStatus=msReset;
   frame.SetRb(&rb);
-  Reset(false);
+  ResetSlot(false);
 }
 
 eModuleStatus cScCamSlot::Status(void)
@@ -1876,7 +1876,7 @@
   return status;
 }
 
-bool cScCamSlot::Reset(bool log)
+bool cScCamSlot::ResetSlot(bool log)
 {
   reset=true; resetTimer.Set(SLOT_RESET_TIME);
   rb.Clear();
@@ -1890,7 +1890,7 @@
   bool dr=cam->IsSoftCSA(false) || ScSetup.ConcurrentFF>0;
   if(dr!=doReply && !IsDecrypting()) {
     PRINTF(L_CORE_CI,"%s.%d: doReply changed, reset triggered",devId,slot);
-    Reset(false);
+    ResetSlot(false);
     doReply=dr;
     }
   if(checkTimer.TimedOut()) {
@@ -2330,7 +2330,7 @@
 {
   cMutexLock lock(&ciMutex);
   PRINTF(L_CORE_CI,"%s: reset of slot %d requested",devId,Slot);
-  return slots[Slot] ? slots[Slot]->Reset():false;
+  return slots[Slot] ? slots[Slot]->ResetSlot():false;
 }
 
 eModuleStatus cCam::ModuleStatus(int Slot)
@@ -2799,10 +2799,19 @@
 :stall(MAX_STALL_MS)
 {
   devId=DevId;
+#ifndef LIBDVBCSA
   cs=get_suggested_cluster_size();
   PRINTF(L_CORE_CSA,"%s: clustersize=%d rangesize=%d",devId,cs,cs*2+5);
   range=MALLOC(unsigned char *,(cs*2+5));
   memset(keys,0,sizeof(keys));
+#else
+  cs = dvbcsa_bs_batch_size();
+  PRINTF(L_CORE_CSA,"%d: batch_size=%d", devId, cs);
+  cs_tsbbatch_even = (dvbcsa_bs_batch_s *) malloc((cs + 1) * sizeof(struct dvbcsa_bs_batch_s));
+  cs_tsbbatch_odd = (dvbcsa_bs_batch_s *) malloc((cs + 1) * sizeof(struct dvbcsa_bs_batch_s));
+  memset(cs_key_even, 0, sizeof(cs_key_even));
+  memset(cs_key_odd, 0, sizeof(cs_key_odd));
+#endif
   memset(pidmap,0,sizeof(pidmap));
   ResetState();
 }
@@ -2810,8 +2819,19 @@
 cDeCSA::~cDeCSA()
 {
   for(int i=0; i<MAX_CSA_IDX; i++)
+#ifndef LIBDVBCSA
     if(keys[i]) free_key_struct(keys[i]);
   free(range);
+#else
+  {
+    if (cs_key_even[i])
+      dvbcsa_bs_key_free(cs_key_even[i]);
+    if (cs_key_odd[i])
+      dvbcsa_bs_key_free(cs_key_odd[i]);
+  }
+  free(cs_tsbbatch_even);
+  free(cs_tsbbatch_odd);
+#endif
 }
 
 void cDeCSA::ResetState(void)
@@ -2819,7 +2839,9 @@
   PRINTF(L_CORE_CSA,"%s: reset state",devId);
   memset(even_odd,0,sizeof(even_odd));
   memset(flags,0,sizeof(flags));
+#ifndef LIBDVBCSA
   lastData=0;
+#endif
 }
 
 void cDeCSA::SetActive(bool on)
@@ -2831,8 +2853,16 @@
 
 bool cDeCSA::GetKeyStruct(int idx)
 {
+#ifndef LIBDVBCSA
   if(!keys[idx]) keys[idx]=get_key_struct();
   return keys[idx]!=0;
+#else
+  if (!cs_key_even[idx])
+    cs_key_even[idx] = dvbcsa_bs_key_alloc();
+  if (!cs_key_odd[idx])
+    cs_key_odd[idx] = dvbcsa_bs_key_alloc();
+  return (cs_key_even[idx] != 0) && (cs_key_odd[idx] != 0);
+#endif
 }
 
 bool cDeCSA::SetDescr(ca_descr_t *ca_descr, bool initial)
@@ -2850,13 +2880,21 @@
       }
     LDUMP(L_CORE_CSA,ca_descr->cw,8,"%s.%d: %4s key set",devId,idx,ca_descr->parity?"odd":"even");
     if(ca_descr->parity==0) {
+#ifndef LIBDVBCSA
       set_even_control_word(keys[idx],ca_descr->cw);
+#else
+      dvbcsa_bs_key_set(ca_descr->cw, cs_key_even[idx]);
+#endif
       if(!CheckNull(ca_descr->cw,8)) flags[idx]|=FL_EVEN_GOOD|FL_ACTIVITY;
       else PRINTF(L_CORE_CSA,"%s.%d: zero even CW",devId,idx);
       wait.Broadcast();
       }
     else {
+#ifndef LIBDVBCSA
       set_odd_control_word(keys[idx],ca_descr->cw);
+#else
+      dvbcsa_bs_key_set(ca_descr->cw, cs_key_odd[idx]);
+#endif
       if(!CheckNull(ca_descr->cw,8)) flags[idx]|=FL_ODD_GOOD|FL_ACTIVITY;
       else PRINTF(L_CORE_CSA,"%s.%d: zero odd CW",devId,idx);
       wait.Broadcast();
@@ -2875,24 +2913,80 @@
   return true;
 }
 
+#ifdef LIBDVBCSA
+unsigned char ts_packet_get_payload_offset(unsigned char *ts_packet)
+{
+  if (ts_packet[0] != TS_SYNC_BYTE)
+    return 0;
+
+  unsigned char adapt_field   = (ts_packet[3] &~ 0xDF) >> 5; // 11x11111
+  unsigned char payload_field = (ts_packet[3] &~ 0xEF) >> 4; // 111x1111
+
+  if (!adapt_field && !payload_field)     // Not allowed
+    return 0;
+
+  if (adapt_field)
+  {
+    unsigned char adapt_len = ts_packet[4];
+    if (payload_field && adapt_len > 182) // Validity checks
+      return 0;
+    if (!payload_field && adapt_len > 183)
+      return 0;
+    if (adapt_len + 4 > TS_SIZE)  // adaptation field takes the whole packet
+      return 0;
+    return 4 + 1 + adapt_len;     // ts header + adapt_field_len_byte + adapt_field_len
+  }
+  else
+  {
+    return 4; // No adaptation, data starts directly after TS header
+  }
+}
+#endif
+
 bool cDeCSA::Decrypt(unsigned char *data, int len, bool force)
 {
   cMutexLock lock(&mutex);
+#ifndef LIBDVBCSA
+  if (!range)
+#else
+  if (!cs_tsbbatch_even || !cs_tsbbatch_odd)
+#endif
+  {
+    PRINTF(L_CORE_CSA,"%s: Error allocating memory for DeCSA", __FUNCTION__);
+    return false;
+  }
+
+#ifndef LIBDVBCSA
   int r=-2, ccs=0, currIdx=-1;
   bool newRange=true;
   range[0]=0;
+#else
+  int ccs = 0, currIdx = -1;
+  int payload_len, offset;
+  int cs_fill_even = 0;
+  int cs_fill_odd = 0;
+#endif
   len-=(TS_SIZE-1);
   int l;
   for(l=0; l<len; l+=TS_SIZE) {
     if(data[l]!=TS_SYNC_BYTE) {       // let higher level cope with that
       PRINTF(L_CORE_CSA,"%s: garbage in TS buffer",devId);
+#ifndef LIBDVBCSA
       if(ccs) force=true;             // prevent buffer stall
+#endif
       break;
       }
     unsigned int ev_od=data[l+3]&0xC0;
     if(ev_od==0x80 || ev_od==0xC0) { // encrypted
+#ifdef LIBDVBCSA
+      offset = ts_packet_get_payload_offset(data + l);
+      payload_len = TS_SIZE - offset;
+#endif
       int idx=pidmap[((data[l+1]<<8)+data[l+2])&(MAX_CSA_PIDS-1)];
       if(currIdx<0 || idx==currIdx) { // same or no index
+#ifdef LIBDVBCSA
+        data[l + 3] &= 0x3f;    // consider it decrypted now
+#endif
         currIdx=idx;
         if(ccs==0 && ev_od!=even_odd[idx]) {
           even_odd[idx]=ev_od;
@@ -2917,20 +3011,38 @@
             else PRINTF(L_CORE_CSA,"%s.%d: not active. wait skipped",devId,idx);
             }
           }
+#ifndef LIBDVBCSA
         if(newRange) {
           r+=2; newRange=false;
           range[r]=&data[l];
           range[r+2]=0;
           }
         range[r+1]=&data[l+TS_SIZE];
+#else
+        if (((ev_od & 0x40) >> 6) == 0)
+        {
+          cs_tsbbatch_even[cs_fill_even].data = &data[l + offset];
+          cs_tsbbatch_even[cs_fill_even].len = payload_len;
+          cs_fill_even++;
+        }
+        else
+        {
+          cs_tsbbatch_odd[cs_fill_odd].data = &data[l + offset];
+          cs_tsbbatch_odd[cs_fill_odd].len = payload_len;
+          cs_fill_odd++;
+        }
+#endif
         if(++ccs>=cs) break;
         }
+#ifndef LIBDVBCSA
       else newRange=true;             // other index, create hole
+#endif
       }
     else {                            // unencrypted
       // nothing, we don't create holes for unencrypted packets
       }
     }
+#ifndef LIBDVBCSA
   int scanTS=l/TS_SIZE;
   int stallP=ccs*100/scanTS;
 
@@ -2977,6 +3089,26 @@
       }
     else PRINTF(L_CORE_CSAVERB,"%s.%d: incomplete ccs=%3d cs=%3d",devId,currIdx,ccs,cs);
     }
+#else
+  if (GetKeyStruct(currIdx))
+  {
+    if (cs_fill_even)
+    {
+      cs_tsbbatch_even[cs_fill_even].data = NULL;
+      dvbcsa_bs_decrypt(cs_key_even[currIdx], cs_tsbbatch_even, 184);
+      cs_fill_even = 0;
+    }
+    if (cs_fill_odd)
+    {
+      cs_tsbbatch_odd[cs_fill_odd].data = NULL;
+      dvbcsa_bs_decrypt(cs_key_odd[currIdx], cs_tsbbatch_odd, 184);
+      cs_fill_odd = 0;
+    }
+
+    stall.Set(MAX_STALL_MS);
+    return true;
+  }
+#endif
   return false;
 }
 
diff -Naur sc-orgnl/cam.h sc/cam.h
--- sc-orgnl/cam.h	2014-04-29 15:09:34.169738565 +0200
+++ sc/cam.h	2014-04-29 15:11:14.005734922 +0200
@@ -235,15 +235,28 @@
 
 #ifndef SASC
 
+#ifdef LIBDVBCSA
+extern "C" {
+#include <dvbcsa/dvbcsa.h>
+}
+#endif
+
 #define MAX_CSA_PIDS 8192
 #define MAX_CSA_IDX  16
 
 class cDeCSA {
 private:
   int cs;
+#ifndef LIBDVBCSA
   unsigned char **range, *lastData;
-  unsigned char pidmap[MAX_CSA_PIDS];
   void *keys[MAX_CSA_IDX];
+#else
+  struct dvbcsa_bs_batch_s *cs_tsbbatch_even;
+  struct dvbcsa_bs_batch_s *cs_tsbbatch_odd;
+  struct dvbcsa_bs_key_s *cs_key_even[MAX_CSA_IDX];
+  struct dvbcsa_bs_key_s *cs_key_odd[MAX_CSA_IDX];
+#endif
+  unsigned char pidmap[MAX_CSA_PIDS];
   unsigned int even_odd[MAX_CSA_IDX], flags[MAX_CSA_IDX];
   cMutex mutex;
   cCondVar wait;
diff -Naur sc-orgnl/debian/changelog sc/debian/changelog
--- sc-orgnl/debian/changelog	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/changelog	2014-04-29 15:11:53.885733467 +0200
@@ -0,0 +1,5 @@
+vdr-plugin-sc (1.0.0-20140419-216-1~trusty) trusty; urgency=medium
+
+  * initial build
+
+ -- x y <x.y@z.com>  Sat, 19 Apr 2014 21:27:21 +0200
diff -Naur sc-orgnl/debian/compat sc/debian/compat
--- sc-orgnl/debian/compat	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/compat	2014-04-29 15:11:53.921733466 +0200
@@ -0,0 +1 @@
+7
diff -Naur sc-orgnl/debian/control sc/debian/control
--- sc-orgnl/debian/control	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/control	2014-04-29 15:11:53.885733467 +0200
@@ -0,0 +1,66 @@
+Source: vdr-plugin-sc
+Section: video
+Priority: extra
+Maintainer: Andrey Pavlenko <andrey.a.pavlenko@gmail.com>
+Build-Depends: debhelper (>= 8.0.0), vdr-dev (>= 2.1.6), 
+ libssl-dev, pkg-config, libdvbcsa-dev
+Standards-Version: 3.9.3
+
+Package: vdr-plugin-sc
+Architecture: any
+Depends: ${shlibs:Depends}, vdr (>= 2.1.6)
+Description: A software emulated CAM
+ The plugin decrypts the scrambling codewords from the incomming ECM stream. The
+ actual descrambling of the video stream is either done by the ECD chip on
+ full-featured DVB cards or with the included FFdecsa implementation on budget
+ cards.
+
+Package: vdr-plugin-sc-cardclient
+Architecture: any
+Depends: ${shlibs:Depends}, vdr-plugin-sc (= ${binary:Version})
+Description: Cardclient system for vdr-plugin-sc
+
+Package: vdr-plugin-sc-conax
+Architecture: any
+Depends: ${shlibs:Depends}, vdr-plugin-sc (= ${binary:Version})
+Description: Conax system for vdr-plugin-sc
+
+Package: vdr-plugin-sc-constcw
+Architecture: any
+Depends: ${shlibs:Depends}, vdr-plugin-sc (= ${binary:Version})
+Description: Constcw system for vdr-plugin-sc
+
+Package: vdr-plugin-sc-cryptoworks
+Architecture: any
+Depends: ${shlibs:Depends}, vdr-plugin-sc (= ${binary:Version})
+Description: Cryptoworks system for vdr-plugin-sc
+
+Package: vdr-plugin-sc-irdeto
+Architecture: any
+Depends: ${shlibs:Depends}, vdr-plugin-sc (= ${binary:Version})
+Description: Irdeto system for vdr-plugin-sc
+
+Package: vdr-plugin-sc-nagra
+Architecture: any
+Depends: ${shlibs:Depends}, vdr-plugin-sc (= ${binary:Version})
+Description: Nagra system for vdr-plugin-sc
+
+Package: vdr-plugin-sc-seca
+Architecture: any
+Depends: ${shlibs:Depends}, vdr-plugin-sc (= ${binary:Version})
+Description: Seca system for vdr-plugin-sc
+
+Package: vdr-plugin-sc-shl
+Architecture: any
+Depends: ${shlibs:Depends}, vdr-plugin-sc (= ${binary:Version})
+Description: SHL system for vdr-plugin-sc
+
+Package: vdr-plugin-sc-viaccess
+Architecture: any
+Depends: ${shlibs:Depends}, vdr-plugin-sc (= ${binary:Version})
+Description: Viaccess system for vdr-plugin-sc
+
+Package: vdr-plugin-sc-videoguard2
+Architecture: any
+Depends: ${shlibs:Depends}, vdr-plugin-sc (= ${binary:Version})
+Description: Videoguard2 system for vdr-plugin-sc
diff -Naur sc-orgnl/debian/patches/DvbDeviceReady.patch sc/debian/patches/DvbDeviceReady.patch
--- sc-orgnl/debian/patches/DvbDeviceReady.patch	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/patches/DvbDeviceReady.patch	2014-04-29 15:11:53.889733467 +0200
@@ -0,0 +1,24 @@
+diff -r 29b7b5f231c8 device-tmpl.c
+--- a/device-tmpl.c	Sat Jul 21 20:51:33 2012 +0200
++++ b/device-tmpl.c	Thu Jan 30 01:10:26 2014 +0400
+@@ -41,7 +41,6 @@
+ #endif //!SASC
+ protected:
+ #ifndef SASC
+-  virtual bool Ready(void);
+   virtual bool SetPid(cPidHandle *Handle, int Type, bool On);
+   virtual bool SetChannelDevice(const cChannel *Channel, bool LiveView);
+   virtual bool OpenDvr(void);
+@@ -164,12 +163,6 @@
+   return cam || hwciadapter;
+ }
+ 
+-bool SCDEVICE::Ready(void)
+-{
+-  return (cam         ? cam->Ready():true) &&
+-         (hwciadapter ? hwciadapter->Ready():true);
+-}
+-
+ bool SCDEVICE::SetPid(cPidHandle *Handle, int Type, bool On)
+ {
+   if(cam) cam->SetPid(Type,Handle->pid,On);
diff -Naur sc-orgnl/debian/patches/libdvbcsa.patch sc/debian/patches/libdvbcsa.patch
--- sc-orgnl/debian/patches/libdvbcsa.patch	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/patches/libdvbcsa.patch	2014-04-29 15:11:53.889733467 +0200
@@ -0,0 +1,519 @@
+diff -Naur vdr-plugin-sc-1.0.0pre-875~29b7b5f231c8/cam.c scplugin/cam.c
+--- vdr-plugin-sc-1.0.0pre-875~29b7b5f231c8/cam.c	2014-04-19 20:27:33.000000000 +0200
++++ scplugin/cam.c	2014-04-19 20:40:43.493743612 +0200
+@@ -2799,10 +2799,19 @@
+ :stall(MAX_STALL_MS)
+ {
+   devId=DevId;
++#ifndef LIBDVBCSA
+   cs=get_suggested_cluster_size();
+   PRINTF(L_CORE_CSA,"%s: clustersize=%d rangesize=%d",devId,cs,cs*2+5);
+   range=MALLOC(unsigned char *,(cs*2+5));
+   memset(keys,0,sizeof(keys));
++#else
++  cs = dvbcsa_bs_batch_size();
++  PRINTF(L_CORE_CSA,"%d: batch_size=%d", devId, cs);
++  cs_tsbbatch_even = (dvbcsa_bs_batch_s *) malloc((cs + 1) * sizeof(struct dvbcsa_bs_batch_s));
++  cs_tsbbatch_odd = (dvbcsa_bs_batch_s *) malloc((cs + 1) * sizeof(struct dvbcsa_bs_batch_s));
++  memset(cs_key_even, 0, sizeof(cs_key_even));
++  memset(cs_key_odd, 0, sizeof(cs_key_odd));
++#endif
+   memset(pidmap,0,sizeof(pidmap));
+   ResetState();
+ }
+@@ -2810,8 +2819,19 @@
+ cDeCSA::~cDeCSA()
+ {
+   for(int i=0; i<MAX_CSA_IDX; i++)
++#ifndef LIBDVBCSA
+     if(keys[i]) free_key_struct(keys[i]);
+   free(range);
++#else
++  {
++    if (cs_key_even[i])
++      dvbcsa_bs_key_free(cs_key_even[i]);
++    if (cs_key_odd[i])
++      dvbcsa_bs_key_free(cs_key_odd[i]);
++  }
++  free(cs_tsbbatch_even);
++  free(cs_tsbbatch_odd);
++#endif
+ }
+ 
+ void cDeCSA::ResetState(void)
+@@ -2819,7 +2839,9 @@
+   PRINTF(L_CORE_CSA,"%s: reset state",devId);
+   memset(even_odd,0,sizeof(even_odd));
+   memset(flags,0,sizeof(flags));
++#ifndef LIBDVBCSA
+   lastData=0;
++#endif
+ }
+ 
+ void cDeCSA::SetActive(bool on)
+@@ -2831,8 +2853,16 @@
+ 
+ bool cDeCSA::GetKeyStruct(int idx)
+ {
++#ifndef LIBDVBCSA
+   if(!keys[idx]) keys[idx]=get_key_struct();
+   return keys[idx]!=0;
++#else
++  if (!cs_key_even[idx])
++    cs_key_even[idx] = dvbcsa_bs_key_alloc();
++  if (!cs_key_odd[idx])
++    cs_key_odd[idx] = dvbcsa_bs_key_alloc();
++  return (cs_key_even[idx] != 0) && (cs_key_odd[idx] != 0);
++#endif
+ }
+ 
+ bool cDeCSA::SetDescr(ca_descr_t *ca_descr, bool initial)
+@@ -2850,13 +2880,21 @@
+       }
+     LDUMP(L_CORE_CSA,ca_descr->cw,8,"%s.%d: %4s key set",devId,idx,ca_descr->parity?"odd":"even");
+     if(ca_descr->parity==0) {
++#ifndef LIBDVBCSA
+       set_even_control_word(keys[idx],ca_descr->cw);
++#else
++      dvbcsa_bs_key_set(ca_descr->cw, cs_key_even[idx]);
++#endif
+       if(!CheckNull(ca_descr->cw,8)) flags[idx]|=FL_EVEN_GOOD|FL_ACTIVITY;
+       else PRINTF(L_CORE_CSA,"%s.%d: zero even CW",devId,idx);
+       wait.Broadcast();
+       }
+     else {
++#ifndef LIBDVBCSA
+       set_odd_control_word(keys[idx],ca_descr->cw);
++#else
++      dvbcsa_bs_key_set(ca_descr->cw, cs_key_odd[idx]);
++#endif
+       if(!CheckNull(ca_descr->cw,8)) flags[idx]|=FL_ODD_GOOD|FL_ACTIVITY;
+       else PRINTF(L_CORE_CSA,"%s.%d: zero odd CW",devId,idx);
+       wait.Broadcast();
+@@ -2875,24 +2913,80 @@
+   return true;
+ }
+ 
++#ifdef LIBDVBCSA
++unsigned char ts_packet_get_payload_offset(unsigned char *ts_packet)
++{
++  if (ts_packet[0] != TS_SYNC_BYTE)
++    return 0;
++
++  unsigned char adapt_field   = (ts_packet[3] &~ 0xDF) >> 5; // 11x11111
++  unsigned char payload_field = (ts_packet[3] &~ 0xEF) >> 4; // 111x1111
++
++  if (!adapt_field && !payload_field)     // Not allowed
++    return 0;
++
++  if (adapt_field)
++  {
++    unsigned char adapt_len = ts_packet[4];
++    if (payload_field && adapt_len > 182) // Validity checks
++      return 0;
++    if (!payload_field && adapt_len > 183)
++      return 0;
++    if (adapt_len + 4 > TS_SIZE)  // adaptation field takes the whole packet
++      return 0;
++    return 4 + 1 + adapt_len;     // ts header + adapt_field_len_byte + adapt_field_len
++  }
++  else
++  {
++    return 4; // No adaptation, data starts directly after TS header
++  }
++}
++#endif
++
+ bool cDeCSA::Decrypt(unsigned char *data, int len, bool force)
+ {
+   cMutexLock lock(&mutex);
++#ifndef LIBDVBCSA
++  if (!range)
++#else
++  if (!cs_tsbbatch_even || !cs_tsbbatch_odd)
++#endif
++  {
++    PRINTF(L_CORE_CSA,"%s: Error allocating memory for DeCSA", __FUNCTION__);
++    return false;
++  }
++
++#ifndef LIBDVBCSA
+   int r=-2, ccs=0, currIdx=-1;
+   bool newRange=true;
+   range[0]=0;
++#else
++  int ccs = 0, currIdx = -1;
++  int payload_len, offset;
++  int cs_fill_even = 0;
++  int cs_fill_odd = 0;
++#endif
+   len-=(TS_SIZE-1);
+   int l;
+   for(l=0; l<len; l+=TS_SIZE) {
+     if(data[l]!=TS_SYNC_BYTE) {       // let higher level cope with that
+       PRINTF(L_CORE_CSA,"%s: garbage in TS buffer",devId);
++#ifndef LIBDVBCSA
+       if(ccs) force=true;             // prevent buffer stall
++#endif
+       break;
+       }
+     unsigned int ev_od=data[l+3]&0xC0;
+     if(ev_od==0x80 || ev_od==0xC0) { // encrypted
++#ifdef LIBDVBCSA
++      offset = ts_packet_get_payload_offset(data + l);
++      payload_len = TS_SIZE - offset;
++#endif
+       int idx=pidmap[((data[l+1]<<8)+data[l+2])&(MAX_CSA_PIDS-1)];
+       if(currIdx<0 || idx==currIdx) { // same or no index
++#ifdef LIBDVBCSA
++        data[l + 3] &= 0x3f;    // consider it decrypted now
++#endif
+         currIdx=idx;
+         if(ccs==0 && ev_od!=even_odd[idx]) {
+           even_odd[idx]=ev_od;
+@@ -2917,20 +3011,38 @@
+             else PRINTF(L_CORE_CSA,"%s.%d: not active. wait skipped",devId,idx);
+             }
+           }
++#ifndef LIBDVBCSA
+         if(newRange) {
+           r+=2; newRange=false;
+           range[r]=&data[l];
+           range[r+2]=0;
+           }
+         range[r+1]=&data[l+TS_SIZE];
++#else
++        if (((ev_od & 0x40) >> 6) == 0)
++        {
++          cs_tsbbatch_even[cs_fill_even].data = &data[l + offset];
++          cs_tsbbatch_even[cs_fill_even].len = payload_len;
++          cs_fill_even++;
++        }
++        else
++        {
++          cs_tsbbatch_odd[cs_fill_odd].data = &data[l + offset];
++          cs_tsbbatch_odd[cs_fill_odd].len = payload_len;
++          cs_fill_odd++;
++        }
++#endif
+         if(++ccs>=cs) break;
+         }
++#ifndef LIBDVBCSA
+       else newRange=true;             // other index, create hole
++#endif
+       }
+     else {                            // unencrypted
+       // nothing, we don't create holes for unencrypted packets
+       }
+     }
++#ifndef LIBDVBCSA
+   int scanTS=l/TS_SIZE;
+   int stallP=ccs*100/scanTS;
+ 
+@@ -2977,6 +3089,26 @@
+       }
+     else PRINTF(L_CORE_CSAVERB,"%s.%d: incomplete ccs=%3d cs=%3d",devId,currIdx,ccs,cs);
+     }
++#else
++  if (GetKeyStruct(currIdx))
++  {
++    if (cs_fill_even)
++    {
++      cs_tsbbatch_even[cs_fill_even].data = NULL;
++      dvbcsa_bs_decrypt(cs_key_even[currIdx], cs_tsbbatch_even, 184);
++      cs_fill_even = 0;
++    }
++    if (cs_fill_odd)
++    {
++      cs_tsbbatch_odd[cs_fill_odd].data = NULL;
++      dvbcsa_bs_decrypt(cs_key_odd[currIdx], cs_tsbbatch_odd, 184);
++      cs_fill_odd = 0;
++    }
++
++    stall.Set(MAX_STALL_MS);
++    return true;
++  }
++#endif
+   return false;
+ }
+ 
+diff -Naur vdr-plugin-sc-1.0.0pre-875~29b7b5f231c8/cam.h scplugin/cam.h
+--- vdr-plugin-sc-1.0.0pre-875~29b7b5f231c8/cam.h	2014-03-16 18:52:55.000000000 +0100
++++ scplugin/cam.h	2014-04-19 20:40:43.497743562 +0200
+@@ -235,15 +235,28 @@
+ 
+ #ifndef SASC
+ 
++#ifdef LIBDVBCSA
++extern "C" {
++#include <dvbcsa/dvbcsa.h>
++}
++#endif
++
+ #define MAX_CSA_PIDS 8192
+ #define MAX_CSA_IDX  16
+ 
+ class cDeCSA {
+ private:
+   int cs;
++#ifndef LIBDVBCSA
+   unsigned char **range, *lastData;
+-  unsigned char pidmap[MAX_CSA_PIDS];
+   void *keys[MAX_CSA_IDX];
++#else
++  struct dvbcsa_bs_batch_s *cs_tsbbatch_even;
++  struct dvbcsa_bs_batch_s *cs_tsbbatch_odd;
++  struct dvbcsa_bs_key_s *cs_key_even[MAX_CSA_IDX];
++  struct dvbcsa_bs_key_s *cs_key_odd[MAX_CSA_IDX];
++#endif
++  unsigned char pidmap[MAX_CSA_PIDS];
+   unsigned int even_odd[MAX_CSA_IDX], flags[MAX_CSA_IDX];
+   cMutex mutex;
+   cCondVar wait;
+diff -Naur vdr-plugin-sc-1.0.0pre-875~29b7b5f231c8/device.c scplugin/device.c
+--- vdr-plugin-sc-1.0.0pre-875~29b7b5f231c8/device.c	2014-03-16 18:52:55.000000000 +0100
++++ scplugin/device.c	2014-04-19 20:40:43.497743562 +0200
+@@ -52,7 +52,7 @@
+   SetDescription("TS buffer on device %d", CardIndex);
+   f=File; size=Size; cardIndex=CardIndex; decsa=DeCsa;
+   delivered=false;
+-  ringBuffer=new cRingBufferLinear(Size,TS_SIZE,true,"FFdecsa-TS");
++  ringBuffer=new cRingBufferLinear(Size,TS_SIZE,true,RINGBUFFERNAME);
+   ringBuffer->SetTimeouts(100,100);
+   if(decsa) decsa->SetActive(true);
+   SetActive(ScActive);
+diff -Naur vdr-plugin-sc-1.0.0pre-875~29b7b5f231c8/device.h scplugin/device.h
+--- vdr-plugin-sc-1.0.0pre-875~29b7b5f231c8/device.h	2014-04-19 20:27:33.000000000 +0200
++++ scplugin/device.h	2014-04-19 20:40:43.497743562 +0200
+@@ -25,6 +25,12 @@
+ #include <vdr/thread.h>
+ #include "misc.h"
+ 
++#ifndef LIBDVBCSA
++#define RINGBUFFERNAME "FFdecsa-TS"
++#else
++#define RINGBUFFERNAME "libdvbcsa-ts"
++#endif
++
+ class cDeCSA;
+ 
+ // ----------------------------------------------------------------
+diff -Naur vdr-plugin-sc-1.0.0pre-875~29b7b5f231c8/Makefile scplugin/Makefile
+--- vdr-plugin-sc-1.0.0pre-875~29b7b5f231c8/Makefile	2014-04-19 20:27:33.000000000 +0200
++++ scplugin/Makefile	2014-04-19 20:49:33.219084063 +0200
+@@ -77,12 +77,18 @@
+ # max number of CAIDs per slot
+ MAXCAID := 64
+ 
++ifndef LIBDVBCSA
+ # FFdeCSA
+ PARALLEL   ?= PARALLEL_128_SSE2
+ CSAFLAGS   ?= -fexpensive-optimizations -fomit-frame-pointer -funroll-loops -O3 -mmmx -msse -msse2 -msse3
+ FFDECSADIR  = FFdecsa
+ FFDECSA     = $(FFDECSADIR)/FFdecsa.o
+ DECSALIB    = $(FFDECSA)
++else
++# libdvbcsa
++DECSALIB = -ldvbcsa
++DEFINES += -DLIBDVBCSA
++endif
+ 
+ ### The main target:
+ 
+@@ -148,11 +154,13 @@
+ 
+ ### Targets:
+ 
+-$(SOFILE): $(OBJS) $(FFDECSA)
+-	$(CXX) $(CXXFLAGS) $(LDFLAGS) -shared $(OBJS) $(FFDECSA) $(LIBS) -o $@
++$(SOFILE): $(OBJS) $(DECSALIB)
++	$(CXX) $(CXXFLAGS) $(LDFLAGS) -shared $(OBJS) $(DECSALIB) $(LIBS) -o $@
+ 
++ifndef LIBDVBCSA
+ $(FFDECSA): $(FFDECSADIR)/*.c $(FFDECSADIR)/*.h
+ 	@$(MAKE) COMPILER="$(CXX)" FLAGS="$(CXXFLAGS) $(CSAFLAGS)" PARALLEL_MODE=$(PARALLEL) -C $(FFDECSADIR) all
++endif
+ 
+ install-lib: $(SOFILE)
+ 	install -D $^ $(DESTDIR)$(LIBDIR)/$^.$(APIVERSION)
+diff -Naur vdr-plugin-sc-1.0.0pre-875~29b7b5f231c8/Makefile.orig scplugin/Makefile.orig
+--- vdr-plugin-sc-1.0.0pre-875~29b7b5f231c8/Makefile.orig	1970-01-01 01:00:00.000000000 +0100
++++ scplugin/Makefile.orig	2014-04-19 20:40:21.000000000 +0200
+@@ -0,0 +1,177 @@
++#
++# Makefile for a Video Disk Recorder plugin
++#
++# $Id$
++
++# The official name of this plugin.
++# This name will be used in the '-P...' option of VDR to load the plugin.
++# By default the main source file also carries this name.
++
++PLUGIN = sc
++
++### The version number of this plugin (taken from the main source file):
++DISTFILE = .distvers
++HGARCHIVE = .hg_archival.txt
++RELEASE := $(shell grep 'define SC_RELEASE' version.h | awk '{ print $$3 }' | sed -e 's/[";]//g')
++SUBREL  := $(shell if test -d .hg; then \
++                     echo -n "HG-"; (hg identify 2>/dev/null || echo -n "Unknown") | sed -e 's/ .*//'; \
++                   elif test -r $(HGARCHIVE); then \
++                     echo -n "AR-"; grep "^node" $(HGARCHIVE) | awk '{ printf "%.12s",$$2 }'; \
++                   elif test -r $(DISTFILE); then \
++                     cat $(DISTFILE); \
++                   else \
++                     echo -n "Unknown"; \
++                   fi)
++VERSION := $(RELEASE)-$(SUBREL)
++SCAPIVERS := $(shell sed -ne '/define SCAPIVERS/ s/^.[a-zA-Z ]*\([0-9]*\).*$$/\1/p' version.h)
++### The directory environment:
++
++# Use package data if installed...otherwise assume we're under the VDR source directory:
++PKGCFG = $(if $(VDRDIR),$(shell pkg-config --variable=$(1) $(VDRDIR)/vdr.pc),$(shell pkg-config --variable=$(1) vdr || pkg-config --variable=$(1) ../../../vdr.pc))
++LIBDIR = $(call PKGCFG,libdir)
++LOCDIR = $(call PKGCFG,locdir)
++PLGCFG = $(call PKGCFG,plgcfg)
++#
++
++SYSDIR  = ./systems
++PREDIR  = ./systems-pre
++LIBS   := -lcrypto
++TMPDIR ?= /tmp
++
++### The compiler options:
++
++export CFLAGS   = $(call PKGCFG,cflags)
++export CXXFLAGS = $(call PKGCFG,cxxflags)
++export SCAPIVERS
++export APIVERSION
++
++### The version number of VDR's plugin API:
++
++APIVERSION = $(call PKGCFG,apiversion)
++
++### Allow user defined options to overwrite defaults:
++
++-include $(PLGCFG)
++
++### The name of the distribution archive:
++
++ARCHIVE = $(PLUGIN)-$(VERSION)
++PACKAGE = vdr-$(ARCHIVE)
++
++### The name of the shared object file:
++
++SOFILE = libvdr-$(PLUGIN).so
++
++### Includes and Defines (add further entries here):
++
++INCLUDES +=
++
++DEFINES += -DPLUGIN_NAME_I18N='"$(PLUGIN)"'
++
++### The object files (add further files here):
++
++OBJS = $(PLUGIN).o data.o filter.o system.o misc.o cam.o device.o version.o \
++       smartcard.o network.o crypto.o system-common.o parse.o log.o \
++       override.o
++
++# max number of CAIDs per slot
++MAXCAID := 64
++
++# FFdeCSA
++PARALLEL   ?= PARALLEL_128_SSE2
++CSAFLAGS   ?= -fexpensive-optimizations -fomit-frame-pointer -funroll-loops -O3 -mmmx -msse -msse2 -msse3
++FFDECSADIR  = FFdecsa
++FFDECSA     = $(FFDECSADIR)/FFdecsa.o
++DECSALIB    = $(FFDECSA)
++
++### The main target:
++
++all: $(SOFILE) systems-pre systems i18n
++
++
++### Implicit rules:
++
++%.o: %.c
++	$(CXX) $(CXXFLAGS) -c $(DEFINES) $(INCLUDES) -o $@ $<
++
++### Dependencies:
++
++MAKEDEP = $(CXX) -MM -MG
++DEPFILES = $(subst i18n.c,,$(subst version.c,,$(OBJS:%.o=%.c)))
++$(DEPFILE): $(DEPFILES) $(wildcard *.h)
++	@$(MAKEDEP) $(CXXFLAGS) $(DEFINES) $(INCLUDES) $(OBJS:%.o=%.c) > $@
++
++-include $(DEPFILE)
++
++### Internationalization (I18N):
++
++PODIR     = po
++I18Npo    = $(wildcard $(PODIR)/*.po)
++I18Nmo    = $(addsuffix .mo, $(foreach file, $(I18Npo), $(basename $(file))))
++I18Nmsgs  = $(addprefix $(DESTDIR)$(LOCDIR)/, $(addsuffix /LC_MESSAGES/vdr-$(PLUGIN).mo, $(notdir $(foreach file, $(I18Npo), $(basename $(file))))))
++I18Npot   = $(PODIR)/$(PLUGIN).pot
++
++%.mo: %.po
++	msgfmt -c -o $@ $<
++
++$(I18Npot): $(wildcard *.c)
++	xgettext -C -cTRANSLATORS --no-wrap --no-location -k -ktr -ktrNOOP --package-name=vdr-$(PLUGIN) --package-version=$(VERSION) --msgid-bugs-address='<see README>' -o $@ `ls $^`
++
++%.po: $(I18Npot)
++	msgmerge -U --no-wrap --no-location --backup=none -q -N $@ $<
++	@touch $@
++
++$(I18Nmsgs): $(DESTDIR)$(LOCDIR)/%/LC_MESSAGES/vdr-$(PLUGIN).mo: $(PODIR)/%.mo
++	install -D -m644 $< $@
++
++.PHONY: i18n systems systems-pre
++i18n: $(I18Nmo) $(I18Npot)
++
++version.c:
++	@echo >$@.new "/* generated file, do not edit */"; \
++		echo >>$@.new 'const char *ScVersion =' '"'$(VERSION)'";'; \
++		diff $@.new $@ >$@.diff 2>&1; \
++		if test -s $@.diff; then mv -f $@.new $@; fi; \
++		rm -f $@.new $@.diff;
++
++systems:
++	@mkdir lib
++	@for i in `ls -A -I ".*" $(SYSDIR)`; do  $(MAKE) LIBDIR=../../lib -f ../../Makefile.system -C "$(SYSDIR)/$$i" all || exit 1; done
++
++systems-pre:
++	@for i in `ls -A -I ".*" $(PREDIR) | grep -- '-$(SCAPIVERS).so.$(APIVERSION)$$'`; do cp -p "$(PREDIR)/$$i" "$(LIBDIR)"; done
++
++contrib:
++	@$(MAKE) -C contrib all
++
++install-i18n: $(I18Nmsgs)
++
++### Targets:
++
++$(SOFILE): $(OBJS) $(FFDECSA)
++	$(CXX) $(CXXFLAGS) $(LDFLAGS) -shared $(OBJS) $(FFDECSA) $(LIBS) -o $@
++
++$(FFDECSA): $(FFDECSADIR)/*.c $(FFDECSADIR)/*.h
++	@$(MAKE) COMPILER="$(CXX)" FLAGS="$(CXXFLAGS) $(CSAFLAGS)" PARALLEL_MODE=$(PARALLEL) -C $(FFDECSADIR) all
++
++install-lib: $(SOFILE)
++	install -D $^ $(DESTDIR)$(LIBDIR)/$^.$(APIVERSION)
++	install -D lib/* $(DESTDIR)$(LIBDIR)/
++
++install: install-lib install-i18n
++
++dist: $(I18Npo) clean
++	@-rm -rf $(TMPDIR)/$(ARCHIVE)
++	@mkdir $(TMPDIR)/$(ARCHIVE)
++	@cp -a * $(TMPDIR)/$(ARCHIVE)
++	@tar czf $(PACKAGE).tgz -C $(TMPDIR) $(ARCHIVE)
++	@-rm -rf $(TMPDIR)/$(ARCHIVE)
++	@echo Distribution package created as $(PACKAGE).tgz
++
++clean-systems:
++	@for i in `ls -A -I ".*" $(SYSDIR)`; do $(MAKE) -f ../../Makefile.system -C "$(SYSDIR)/$$i" clean; done
++
++clean: clean-systems
++	@-rm -f $(PODIR)/*.mo $(PODIR)/*.pot
++	@-rm -f $(OBJS) $(DEPFILE) *.so *.tgz core* *~
++	@-rm -rf lib
diff -Naur sc-orgnl/debian/patches/Makefile.patch sc/debian/patches/Makefile.patch
--- sc-orgnl/debian/patches/Makefile.patch	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/patches/Makefile.patch	2014-04-29 15:11:53.889733467 +0200
@@ -0,0 +1,405 @@
+diff -r 29b7b5f231c8 Makefile
+--- a/Makefile	Sat Jul 21 20:51:33 2012 +0200
++++ b/Makefile	Thu Jan 24 23:45:54 2013 +0400
+@@ -1,29 +1,15 @@
+ #
+-# Softcam plugin to VDR
++# Makefile for a Video Disk Recorder plugin
+ #
+-# This code is free software; you can redistribute it and/or
+-# modify it under the terms of the GNU General Public License
+-# as published by the Free Software Foundation; either version 2
+-# of the License, or (at your option) any later version.
+-#
+-# This code is distributed in the hope that it will be useful,
+-# but WITHOUT ANY WARRANTY; without even the implied warranty of
+-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+-# GNU General Public License for more details.
+-#
+-# You should have received a copy of the GNU General Public License
+-# along with this program; if not, write to the Free Software
+-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+-# Or, point your browser to http://www.gnu.org/copyleft/gpl.html
++# $Id$
+ 
+ # The official name of this plugin.
+ # This name will be used in the '-P...' option of VDR to load the plugin.
+ # By default the main source file also carries this name.
+-#
++
+ PLUGIN = sc
+ 
+-### The version number of this plugin
+-
++### The version number of this plugin (taken from the main source file):
+ DISTFILE = .distvers
+ HGARCHIVE = .hg_archival.txt
+ RELEASE := $(shell grep 'define SC_RELEASE' version.h | awk '{ print $$3 }' | sed -e 's/[";]//g')
+@@ -38,49 +24,49 @@
+                    fi)
+ VERSION := $(RELEASE)-$(SUBREL)
+ SCAPIVERS := $(shell sed -ne '/define SCAPIVERS/ s/^.[a-zA-Z ]*\([0-9]*\).*$$/\1/p' version.h)
+-
+ ### The directory environment:
+ 
+-VDRDIR = ../../..
+-LIBDIR = ../../lib
+-SYSDIR = ./systems
+-PREDIR = ./systems-pre
+-TMPDIR = /tmp
++# Use package data if installed...otherwise assume we're under the VDR source directory:
++PKGCFG = $(if $(VDRDIR),$(shell pkg-config --variable=$(1) $(VDRDIR)/vdr.pc),$(shell pkg-config --variable=$(1) vdr || pkg-config --variable=$(1) ../../../vdr.pc))
++LIBDIR = $(call PKGCFG,libdir)
++LOCDIR = $(call PKGCFG,locdir)
++PLGCFG = $(call PKGCFG,plgcfg)
++#
+ 
+-### The C++ compiler and options:
++SYSDIR  = ./systems
++PREDIR  = ./systems-pre
++LIBS   := -lcrypto
++TMPDIR ?= /tmp
+ 
+-CXX      ?= g++
+-CXXFLAGS ?= -O2 -g -Wall -Woverloaded-virtual
++### The compiler options:
+ 
+-### Includes and Defines
++export CFLAGS   = $(call PKGCFG,cflags)
++export CXXFLAGS = $(call PKGCFG,cxxflags)
++export SCAPIVERS
++export APIVERSION
+ 
+-INCLUDES      = -I$(VDRDIR)/include
+-DEFINES       = -DPLUGIN_NAME_I18N='"$(PLUGIN)"'
+-SHAREDDEFINES = -DAPIVERSNUM=$(APIVERSNUM) -D_GNU_SOURCE
+-LIBS          = -lcrypto
+-SHAREDLIBS    =
++### The version number of VDR's plugin API:
++
++APIVERSION = $(call PKGCFG,apiversion)
+ 
+ ### Allow user defined options to overwrite defaults:
+ 
+--include $(VDRDIR)/Make.global
+--include $(VDRDIR)/Make.config
+--include Make.config
++-include $(PLGCFG)
+ 
+-# we need this ATM because of the helper.h macros...
+-CXXFLAGS += -fno-strict-aliasing
++### The name of the distribution archive:
+ 
+-### The version number of VDR (taken from VDR's "config.h"):
++ARCHIVE = $(PLUGIN)-$(VERSION)
++PACKAGE = vdr-$(ARCHIVE)
+ 
+-VDRVERSION := $(shell sed -ne '/define VDRVERSION/ s/^.*"\(.*\)".*$$/\1/p' $(VDRDIR)/include/vdr/config.h)
+-APIVERSION := $(shell sed -ne '/define APIVERSION/ s/^.*"\(.*\)".*$$/\1/p' $(VDRDIR)/include/vdr/config.h)
+-ifeq ($(strip $(APIVERSION)),)
+-   APIVERSION = $(VDRVERSION)
+-endif
+-VDRVERSNUM := $(shell sed -ne '/define VDRVERSNUM/ s/^.[a-zA-Z ]*\([0-9]*\) .*$$/\1/p' $(VDRDIR)/include/vdr/config.h)
+-APIVERSNUM := $(shell sed -ne '/define APIVERSNUM/ s/^.[a-zA-Z ]*\([0-9]*\) .*$$/\1/p' $(VDRDIR)/include/vdr/config.h)
+-ifeq ($(strip $(APIVERSNUM)),)
+-   APIVERSNUM = $(VDRVERSNUM)
+-endif
++### The name of the shared object file:
++
++SOFILE = libvdr-$(PLUGIN).so
++
++### Includes and Defines (add further entries here):
++
++INCLUDES +=
++
++DEFINES += -DPLUGIN_NAME_I18N='"$(PLUGIN)"'
+ 
+ ### The object files (add further files here):
+ 
+@@ -88,162 +74,69 @@
+        smartcard.o network.o crypto.o system-common.o parse.o log.o \
+        override.o
+ 
++# max number of CAIDs per slot
++MAXCAID := 64
++
++# FFdeCSA
++PARALLEL   ?= PARALLEL_128_SSE2
++CSAFLAGS   ?= -fexpensive-optimizations -fomit-frame-pointer -funroll-loops -O3 -mmmx -msse -msse2 -msse3
++FFDECSADIR  = FFdecsa
++FFDECSA     = $(FFDECSADIR)/FFdecsa.o
++DECSALIB    = $(FFDECSA)
++
++### The main target:
++
++all: $(SOFILE) systems-pre systems i18n
++
++
++### Implicit rules:
++
++%.o: %.c
++	$(CXX) $(CXXFLAGS) -c $(DEFINES) $(INCLUDES) -o $@ $<
++
++### Dependencies:
++
++MAKEDEP = $(CXX) -MM -MG
++DEPFILES = $(subst i18n.c,,$(subst version.c,,$(OBJS:%.o=%.c)))
++$(DEPFILE): $(DEPFILES) $(wildcard *.h)
++	@$(MAKEDEP) $(CXXFLAGS) $(DEFINES) $(INCLUDES) $(OBJS:%.o=%.c) > $@
++
++-include $(DEPFILE)
++
+ ### Internationalization (I18N):
+ 
+ PODIR     = po
++I18Npo    = $(wildcard $(PODIR)/*.po)
++I18Nmo    = $(addsuffix .mo, $(foreach file, $(I18Npo), $(basename $(file))))
++I18Nmsgs  = $(addprefix $(DESTDIR)$(LOCDIR)/, $(addsuffix /LC_MESSAGES/vdr-$(PLUGIN).mo, $(notdir $(foreach file, $(I18Npo), $(basename $(file))))))
+ I18Npot   = $(PODIR)/$(PLUGIN).pot
+-I18Nmo    = vdr-$(PLUGIN).mo
+-I18Nmsgs  = $(addprefix $(LOCALEDIR)/,$(addsuffix /LC_MESSAGES/$(I18Nmo),$(notdir $(foreach file, $(wildcard $(PODIR)/*.po), $(basename $(file))))))
+-LOCALEDIR = $(VDRDIR)/locale
+-
+-### VDR version dependant
+-
+-# test VDR version
+-BYVERS = $(strip $(shell if test $(APIVERSNUM) -ge 010703; then echo "*"; fi))
+-# test if PlayTsVideo() exists (e.g. TSplay patch)
+-BYTSPL = $(strip $(shell grep -l 'PlayTsVideo' $(VDRDIR)/include/vdr/device.h))
+-
+-ifneq ($(BYVERS)$(BYTSPL),)
+-  SHAREDDEFINES += -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE
+-endif
+-
+-#
+-# generic stuff
+-#
+-
+-# smartcard default port (dropped)
+-ifdef DEFAULT_PORT
+-  $(error DEFAULT_PORT support was removed, use cardslot.conf)
+-endif
+-
+-ifdef WITH_PCSC
+-  DEFINES  += -DWITH_PCSC
+-  LIBS     += -lpcsclite
+-endif
+-
+-HAVE_SD := $(wildcard ../dvbsddevice/dvbsddevice.c)
+-ifneq ($(strip $(HAVE_SD)),)
+-  DEFINES += -DWITH_SDDVB
+-  DEVPLUGTARGETS += $(LIBDIR)/libsc-dvbsddevice-$(SCAPIVERS).so.$(APIVERSION)
+-endif
+-DEVPLUGOBJS += device-sd.o
+-HAVE_HD := $(wildcard ../dvbhddevice/dvbhddevice.c)
+-ifneq ($(strip $(HAVE_HD)),)
+-  HDVERS := $(shell sed -ne '/*VERSION/ s/^.*=.*"\(.*\)".*$$/\1/p' ../dvbhddevice/dvbhddevice.c)
+-  ifeq ($(findstring dag,$(HDVERS)),)
+-    DEFINES += -DWITH_HDDVB
+-    DEVPLUGTARGETS += $(LIBDIR)/libsc-dvbhddevice-$(SCAPIVERS).so.$(APIVERSION)
+-  endif
+-endif
+-DEVPLUGOBJS += device-hd.o
+-
+-# max number of CAIDs per slot
+-MAXCAID := $(shell sed -ne '/define MAXCASYSTEMIDS/ s/^.[a-zA-Z ]*\([0-9]*\).*$$/\1/p' $(VDRDIR)/ci.c)
+-ifneq ($(strip $(MAXCAID)),)
+-  DEFINES += -DVDR_MAXCAID=$(MAXCAID)
+-endif
+-
+-# FFdeCSA
+-CPUOPT     ?= pentium
+-PARALLEL   ?= PARALLEL_32_INT
+-CSAFLAGS   ?= -Wall -fPIC -g -O3 -mmmx -fomit-frame-pointer -fexpensive-optimizations -funroll-loops
+-FFDECSADIR  = FFdecsa
+-FFDECSA     = $(FFDECSADIR)/FFdecsa.o
+-FFDECSATEST = $(FFDECSADIR)/FFdecsa_test.done
+-
+-# SASC
+-ifdef SASC
+-DEFINES += -DSASC
+-FFDECSA =
+-FFDECSATEST =
+-endif
+-
+-# export for system makefiles
+-export SCAPIVERS
+-export APIVERSION
+-export INCLUDES
+-export SHAREDDEFINES
+-export SHAREDLIBS
+-export CXX
+-export CXXFLAGS
+-
+-### Targets:
+-
+-ifdef STATIC
+-BUILDTARGETS = $(LIBDIR)/libvdr-$(PLUGIN).a
+-SHAREDDEFINES += -DSTATICBUILD
+-else
+-BUILDTARGETS = $(LIBDIR)/libvdr-$(PLUGIN).so.$(APIVERSION) systems-pre $(DEVPLUGTARGETS)
+-endif
+-BUILDTARGETS += $(FFDECSATEST) systems i18n
+-
+-all: $(BUILDTARGETS)
+-.PHONY: i18n systems systems-pre contrib clean clean-core clean-systems clean-pre dist srcdist
+-
+-# Dependencies:
+-
+-MAKEDEP = g++ -MM -MG
+-DEPFILE = .dependencies
+-DEPFILES = $(subst i18n.c,,$(subst version.c,,$(OBJS:%.o=%.c)))
+-$(DEPFILE): $(DEPFILES) $(wildcard *.h)
+-	@$(MAKEDEP) $(DEFINES) $(SHAREDDEFINES) $(INCLUDES) $(DEPFILES) > $@
+-
+--include $(DEPFILE)
+-
+-# Rules
+-
+-%.o: %.c
+-	$(CXX) $(CXXFLAGS) -c $(DEFINES) $(SHAREDDEFINES) $(INCLUDES) $<
+-
+-libvdr-$(PLUGIN).so: $(OBJS) $(FFDECSA)
+-	$(CXX) $(CXXFLAGS) -shared $(OBJS) $(FFDECSA) $(LIBS) $(SHAREDLIBS) -o $@
+-
+-$(LIBDIR)/libvdr-$(PLUGIN).so.$(APIVERSION): libvdr-$(PLUGIN).so
+-	@cp -p $< $@
+-
+-$(LIBDIR)/libvdr-$(PLUGIN).a: $(OBJS)
+-	$(AR) r $@ $(OBJS)
+-
+-libsc-dvbsddevice.so: device-sd.o
+-	$(CXX) $(CXXFLAGS) -shared $< $(SHAREDLIBS) -o $@
+-
+-$(LIBDIR)/libsc-dvbsddevice-$(SCAPIVERS).so.$(APIVERSION): libsc-dvbsddevice.so
+-	@cp -p $< $@
+-
+-libsc-dvbhddevice.so: device-hd.o
+-	$(CXX) $(CXXFLAGS) -shared $< $(SHAREDLIBS) -o $@
+-
+-$(LIBDIR)/libsc-dvbhddevice-$(SCAPIVERS).so.$(APIVERSION): libsc-dvbhddevice.so
+-	@cp -p $< $@
+-
+-$(FFDECSA) $(FFDECSATEST): $(FFDECSADIR)/*.c $(FFDECSADIR)/*.h
+-	@$(MAKE) COMPILER="$(CXX)" FLAGS="$(CSAFLAGS) -march=$(CPUOPT)" PARALLEL_MODE=$(PARALLEL) -C $(FFDECSADIR) all
+-
+-$(I18Npot): $(shell grep -rl '\(tr\|trNOOP\)(\".*\")' *.c $(SYSDIR))
+-	xgettext -C -cTRANSLATORS --no-wrap --no-location -k -ktr -ktrNOOP --package-name=VDR-SC --package-version=$(VERSION) --msgid-bugs-address='<noone@nowhere.org>' -o $@ `ls $^`
+-
+-%.po: $(I18Npot)
+-	msgmerge -U --no-wrap --no-location --no-fuzzy-matching --backup=none -q $@ $<
+-	@touch $@
+ 
+ %.mo: %.po
+ 	msgfmt -c -o $@ $<
+ 
+-$(I18Nmsgs): $(LOCALEDIR)/%/LC_MESSAGES/$(I18Nmo): $(PODIR)/%.mo
+-	@mkdir -p $(dir $@)
+-	cp $< $@
++$(I18Npot): $(wildcard *.c)
++	xgettext -C -cTRANSLATORS --no-wrap --no-location -k -ktr -ktrNOOP --package-name=vdr-$(PLUGIN) --package-version=$(VERSION) --msgid-bugs-address='<see README>' -o $@ `ls $^`
+ 
+-i18n: $(I18Nmsgs)
++%.po: $(I18Npot)
++	msgmerge -U --no-wrap --no-location --backup=none -q -N $@ $<
++	@touch $@
+ 
+-version.c: FORCE
++$(I18Nmsgs): $(DESTDIR)$(LOCDIR)/%/LC_MESSAGES/vdr-$(PLUGIN).mo: $(PODIR)/%.mo
++	install -D -m644 $< $@
++
++.PHONY: i18n systems systems-pre
++i18n: $(I18Nmo) $(I18Npot)
++
++version.c:
+ 	@echo >$@.new "/* generated file, do not edit */"; \
+-	 echo >>$@.new 'const char *ScVersion =' '"'$(VERSION)'";'; \
+-	 diff $@.new $@ >$@.diff 2>&1; \
+-	 if test -s $@.diff; then mv -f $@.new $@; fi; \
+-	 rm -f $@.new $@.diff;
++		echo >>$@.new 'const char *ScVersion =' '"'$(VERSION)'";'; \
++		diff $@.new $@ >$@.diff 2>&1; \
++		if test -s $@.diff; then mv -f $@.new $@; fi; \
++		rm -f $@.new $@.diff;
+ 
+ systems:
+-	@for i in `ls -A -I ".*" $(SYSDIR)`; do $(MAKE) -f ../../Makefile.system -C "$(SYSDIR)/$$i" all || exit 1; done
++	@mkdir lib
++	@for i in `ls -A -I ".*" $(SYSDIR)`; do  $(MAKE) LIBDIR=../../lib -f ../../Makefile.system -C "$(SYSDIR)/$$i" all || exit 1; done
+ 
+ systems-pre:
+ 	@for i in `ls -A -I ".*" $(PREDIR) | grep -- '-$(SCAPIVERS).so.$(APIVERSION)$$'`; do cp -p "$(PREDIR)/$$i" "$(LIBDIR)"; done
+@@ -251,45 +144,34 @@
+ contrib:
+ 	@$(MAKE) -C contrib all
+ 
++install-i18n: $(I18Nmsgs)
++
++### Targets:
++
++$(SOFILE): $(OBJS) $(FFDECSA)
++	$(CXX) $(CXXFLAGS) $(LDFLAGS) -shared $(OBJS) $(FFDECSA) $(LIBS) -o $@
++
++$(FFDECSA): $(FFDECSADIR)/*.c $(FFDECSADIR)/*.h
++	@$(MAKE) COMPILER="$(CXX)" FLAGS="$(CXXFLAGS) $(CSAFLAGS)" PARALLEL_MODE=$(PARALLEL) -C $(FFDECSADIR) all
++
++install-lib: $(SOFILE)
++	install -D $^ $(DESTDIR)$(LIBDIR)/$^.$(APIVERSION)
++	install -D lib/* $(DESTDIR)$(LIBDIR)/
++
++install: install-lib install-i18n
++
++dist: $(I18Npo) clean
++	@-rm -rf $(TMPDIR)/$(ARCHIVE)
++	@mkdir $(TMPDIR)/$(ARCHIVE)
++	@cp -a * $(TMPDIR)/$(ARCHIVE)
++	@tar czf $(PACKAGE).tgz -C $(TMPDIR) $(ARCHIVE)
++	@-rm -rf $(TMPDIR)/$(ARCHIVE)
++	@echo Distribution package created as $(PACKAGE).tgz
++
+ clean-systems:
+ 	@for i in `ls -A -I ".*" $(SYSDIR)`; do $(MAKE) -f ../../Makefile.system -C "$(SYSDIR)/$$i" clean; done
+ 
+-clean-core:
+-	@$(MAKE) -C testing clean
+-	@$(MAKE) -C contrib clean
+-	@if test -d $(FFDECSADIR); then $(MAKE) -C $(FFDECSADIR) clean; fi
+-	@-rm -f $(LIBDIR)/libsc-*-$(SCAPIVERS).so.$(APIVERSION)
+-	@-rm -f $(LIBDIR)/libvdr-$(PLUGIN).a $(LIBDIR)/libsc-*.a
+-	@-rm -f $(OBJS) $(DEVPLUGOBJS) $(DEPFILE) version.c *.so *.tar.gz core* *~
+-	@-rm -f $(PODIR)/*.mo
+-
+-clean-pre:
+-	@-find "$(PREDIR)" -type f -not -name ".empty" -not -iname "*-$(SCAPIVERS).so.*" | xargs rm -f
+-
+-clean: clean-core clean-systems
+-
+-dist: ARCHIVE := $(PLUGIN)-$(RELEASE)
+-dist: clean-core
+-	@for i in `ls -A -I ".*" $(SYSDIR)`; do $(MAKE) -f ../../Makefile.system -C "$(SYSDIR)/$$i" dist; done
+-	@-rm -rf $(TMPDIR)/$(ARCHIVE)
+-	@mkdir $(TMPDIR)/$(ARCHIVE)
+-	@cp -a * $(TMPDIR)/$(ARCHIVE)
+-	@echo -n "release" >$(TMPDIR)/$(ARCHIVE)/$(DISTFILE)
+-	@path="$(TMPDIR)/$(ARCHIVE)/$(notdir $(SYSDIR))";\
+-	 for i in `ls -A -I ".*" $$path`; do if [ -f "$$path/$$i/nonpublic.mk" ]; then rm -rf "$$path/$$i"; fi; if [ -f "$$path/$$i/nonpublic.sh" ]; then (cd $$path/$$i ; source ./nonpublic.sh ; rm ./nonpublic.sh); fi; done
+-	@strip --strip-unneeded --preserve-dates $(TMPDIR)/$(ARCHIVE)/$(notdir $(PREDIR))/* || true
+-	@tar czf vdr-$(ARCHIVE).tar.gz -C $(TMPDIR) $(ARCHIVE)
+-	@-rm -rf $(TMPDIR)/$(ARCHIVE)
+-	@echo Distribution package created as vdr-$(ARCHIVE).tar.gz
+-
+-copy: ARCHIVE := $(PLUGIN)-$(VERSION)
+-copy: clean clean-pre
+-	@-rm -rf $(TMPDIR)/$(ARCHIVE)
+-	@mkdir $(TMPDIR)/$(ARCHIVE)
+-	@cp -a .hgtags .hgignore * $(TMPDIR)/$(ARCHIVE)
+-	@echo -n $(SUBREL) | sed -e 's/HG-/CP-/' >$(TMPDIR)/$(ARCHIVE)/$(DISTFILE)
+-	@tar czf vdr-$(ARCHIVE).tar.gz -C $(TMPDIR) $(ARCHIVE)
+-	@-rm -rf $(TMPDIR)/$(ARCHIVE)
+-	@echo Full copy package created as vdr-$(ARCHIVE).tar.gz
+-
+-FORCE:
++clean: clean-systems
++	@-rm -f $(PODIR)/*.mo $(PODIR)/*.pot
++	@-rm -f $(OBJS) $(DEPFILE) *.so *.tgz core* *~
++	@-rm -rf lib
diff -Naur sc-orgnl/debian/patches/MAXDEVICES.patch sc/debian/patches/MAXDEVICES.patch
--- sc-orgnl/debian/patches/MAXDEVICES.patch	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/patches/MAXDEVICES.patch	2014-04-29 15:11:53.889733467 +0200
@@ -0,0 +1,30 @@
+diff -Naur vdr-plugin-sc-1.0.0pre-875~29b7b5f231c8/device.c vdr-plugin-sc-1.0.0pre-875~29b7b5f231c8-new/device.c
+--- vdr-plugin-sc-1.0.0pre-875~29b7b5f231c8/device.c	2014-04-19 20:57:26.393835329 +0200
++++ vdr-plugin-sc-1.0.0pre-875~29b7b5f231c8-new/device.c	2014-04-19 21:06:52.097859728 +0200
+@@ -357,7 +357,7 @@
+   *vdr_nci=0; *vdr_ud=vdr_save_ud;
+ 
+   int i, found=0;
+-  for(i=0; i<MAXDVBDEVICES; i++) {
++  for(i=0; i<MAXDEVICES; i++) {
+     if(UseDevice(NextCardIndex())) {
+       char name[128];
+       cScDevices::DvbName(DEV_DVB_FRONTEND,i,0,name,sizeof(name));
+@@ -382,7 +382,7 @@
+       }
+     else NextCardIndex(1);
+     }
+-  NextCardIndex(MAXDVBDEVICES-i);
++  NextCardIndex(MAXDEVICES-i);
+   if(found>0) PRINTF(L_GEN_INFO,"captured %d video device%s",found,found>1 ? "s" : "");
+   else PRINTF(L_GEN_INFO,"no DVB device captured");
+   return found>0;
+@@ -411,7 +411,7 @@
+ 
+ void cScDevices::SetForceBudget(int n)
+ {
+-   if(n>=0 && n<MAXDVBDEVICES) budget|=(1<<n);
++   if(n>=0 && n<MAXDEVICES) budget|=(1<<n);
+ }
+ 
+ bool cScDevices::ForceBudget(int n)
diff -Naur sc-orgnl/debian/patches/MAXDVBDEVICES.patch sc/debian/patches/MAXDVBDEVICES.patch
--- sc-orgnl/debian/patches/MAXDVBDEVICES.patch	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/patches/MAXDVBDEVICES.patch	2014-04-29 15:11:53.889733467 +0200
@@ -0,0 +1,14 @@
+diff -r 29b7b5f231c8 device.h
+--- a/device.h	Sat Jul 21 20:51:33 2012 +0200
++++ b/device.h	Wed Jan 08 16:48:13 2014 +0400
+@@ -45,6 +45,10 @@
+ #define DVB_DEV_SPEC CardIndex(),0
+ #endif
+ 
++#ifndef MAXDEVICES
++#define MAXDEVICES  8
++#endif
++
+ // ----------------------------------------------------------------
+ 
+ #ifndef SASC
diff -Naur sc-orgnl/debian/patches/ResetSlot.patch sc/debian/patches/ResetSlot.patch
--- sc-orgnl/debian/patches/ResetSlot.patch	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/patches/ResetSlot.patch	2014-04-29 15:11:53.889733467 +0200
@@ -0,0 +1,48 @@
+diff -r 29b7b5f231c8 cam.c
+--- a/cam.c	Sat Jul 21 20:51:33 2012 +0200
++++ b/cam.c	Wed Jan 08 16:47:38 2014 +0400
+@@ -1841,7 +1841,7 @@
+   cScCamSlot(cCam *Cam, const char *DevId, int Slot);
+   void Process(const unsigned char *data, int len);
+   eModuleStatus Status(void);
+-  bool Reset(bool log=true);
++  bool ResetSlot(bool log=true);
+   cCiFrame *Frame(void) { return &frame; }
+   };
+ 
+@@ -1853,7 +1853,7 @@
+   cam=Cam; devId=DevId; slot=Slot;
+   version=0; caids[0]=0; doReply=false; lastStatus=msReset;
+   frame.SetRb(&rb);
+-  Reset(false);
++  ResetSlot(false);
+ }
+ 
+ eModuleStatus cScCamSlot::Status(void)
+@@ -1876,7 +1876,7 @@
+   return status;
+ }
+ 
+-bool cScCamSlot::Reset(bool log)
++bool cScCamSlot::ResetSlot(bool log)
+ {
+   reset=true; resetTimer.Set(SLOT_RESET_TIME);
+   rb.Clear();
+@@ -1890,7 +1890,7 @@
+   bool dr=cam->IsSoftCSA(false) || ScSetup.ConcurrentFF>0;
+   if(dr!=doReply && !IsDecrypting()) {
+     PRINTF(L_CORE_CI,"%s.%d: doReply changed, reset triggered",devId,slot);
+-    Reset(false);
++    ResetSlot(false);
+     doReply=dr;
+     }
+   if(checkTimer.TimedOut()) {
+@@ -2330,7 +2330,7 @@
+ {
+   cMutexLock lock(&ciMutex);
+   PRINTF(L_CORE_CI,"%s: reset of slot %d requested",devId,Slot);
+-  return slots[Slot] ? slots[Slot]->Reset():false;
++  return slots[Slot] ? slots[Slot]->ResetSlot():false;
+ }
+ 
+ eModuleStatus cCam::ModuleStatus(int Slot)
diff -Naur sc-orgnl/debian/plugin.sc.conf sc/debian/plugin.sc.conf
--- sc-orgnl/debian/plugin.sc.conf	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/plugin.sc.conf	2014-04-29 15:11:53.889733467 +0200
@@ -0,0 +1,6 @@
+# Commandline options
+#
+# -B N    --budget=N        forces DVB device N to budget mode (using FFdecsa)
+# -E CMD  --external-au=CMD script for external key updates
+
+-B0 -B1 -B2
diff -Naur sc-orgnl/debian/rules sc/debian/rules
--- sc-orgnl/debian/rules	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/rules	2014-04-29 15:11:53.885733467 +0200
@@ -0,0 +1,27 @@
+#!/usr/bin/make -f
+
+DIR := $(CURDIR)
+DESTDIR := $(DIR)/debian/tmp
+NPROC := $(shell getconf _NPROCESSORS_ONLN)
+
+export LIBDVBCSA=1
+
+%:
+	dh $@ 
+
+override_dh_auto_build:
+	dh_auto_build -- -j$(NPROC)
+
+override_dh_auto_install:
+	dh_auto_build -- install DESTDIR="$(DESTDIR)"
+	
+	# SC configs
+	[ -d "$(DESTDIR)/etc/vdr/plugins/sc" ] || mkdir -p "$(DESTDIR)/etc/vdr/plugins/sc"
+	sed -e 's/^[^#]/# \0/' \
+	    < "$(DIR)/examples/cardclient.conf.example" \
+	    > "$(DESTDIR)/etc/vdr/plugins/sc/cardclient.conf"
+	cp "$(DIR)/debian/plugin.sc.conf" "$(DESTDIR)/etc/vdr/plugins/plugin.sc.conf"
+
+override_dh_installdocs:
+
+override_dh_installchangelogs:
diff -Naur sc-orgnl/debian/source/format sc/debian/source/format
--- sc-orgnl/debian/source/format	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/source/format	2014-04-29 15:11:53.893733467 +0200
@@ -0,0 +1 @@
+3.0 (native)
diff -Naur sc-orgnl/debian/source/options sc/debian/source/options
--- sc-orgnl/debian/source/options	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/source/options	2014-04-29 15:11:53.893733467 +0200
@@ -0,0 +1 @@
+compression = "bzip2"
\ Kein Zeilenumbruch am Dateiende.
diff -Naur sc-orgnl/debian/vdr-plugin-sc-cardclient.install sc/debian/vdr-plugin-sc-cardclient.install
--- sc-orgnl/debian/vdr-plugin-sc-cardclient.install	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/vdr-plugin-sc-cardclient.install	2014-04-29 15:11:53.893733467 +0200
@@ -0,0 +1,2 @@
+etc/vdr/plugins/sc/cardclient.conf
+usr/lib/vdr/plugins/libsc-*cardclient*.so.*
diff -Naur sc-orgnl/debian/vdr-plugin-sc-conax.install sc/debian/vdr-plugin-sc-conax.install
--- sc-orgnl/debian/vdr-plugin-sc-conax.install	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/vdr-plugin-sc-conax.install	2014-04-29 15:11:53.917733466 +0200
@@ -0,0 +1 @@
+usr/lib/vdr/plugins/libsc-*conax*.so.*
diff -Naur sc-orgnl/debian/vdr-plugin-sc-constcw.install sc/debian/vdr-plugin-sc-constcw.install
--- sc-orgnl/debian/vdr-plugin-sc-constcw.install	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/vdr-plugin-sc-constcw.install	2014-04-29 15:11:53.885733467 +0200
@@ -0,0 +1 @@
+usr/lib/vdr/plugins/libsc-*constcw*.so.*
diff -Naur sc-orgnl/debian/vdr-plugin-sc-cryptoworks.install sc/debian/vdr-plugin-sc-cryptoworks.install
--- sc-orgnl/debian/vdr-plugin-sc-cryptoworks.install	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/vdr-plugin-sc-cryptoworks.install	2014-04-29 15:11:53.885733467 +0200
@@ -0,0 +1 @@
+usr/lib/vdr/plugins/libsc-*cryptoworks*.so.*
diff -Naur sc-orgnl/debian/vdr-plugin-sc.install sc/debian/vdr-plugin-sc.install
--- sc-orgnl/debian/vdr-plugin-sc.install	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/vdr-plugin-sc.install	2014-04-29 15:11:53.885733467 +0200
@@ -0,0 +1,3 @@
+etc/vdr/plugins/plugin.sc.conf
+usr/share/locale
+usr/lib/vdr/plugins/libvdr-sc.so.*
diff -Naur sc-orgnl/debian/vdr-plugin-sc-irdeto.install sc/debian/vdr-plugin-sc-irdeto.install
--- sc-orgnl/debian/vdr-plugin-sc-irdeto.install	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/vdr-plugin-sc-irdeto.install	2014-04-29 15:11:53.893733467 +0200
@@ -0,0 +1 @@
+usr/lib/vdr/plugins/libsc-*irdeto*.so.*
diff -Naur sc-orgnl/debian/vdr-plugin-sc-nagra.install sc/debian/vdr-plugin-sc-nagra.install
--- sc-orgnl/debian/vdr-plugin-sc-nagra.install	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/vdr-plugin-sc-nagra.install	2014-04-29 15:11:53.885733467 +0200
@@ -0,0 +1 @@
+usr/lib/vdr/plugins/libsc-*nagra*.so.*
diff -Naur sc-orgnl/debian/vdr-plugin-sc.postinst sc/debian/vdr-plugin-sc.postinst
--- sc-orgnl/debian/vdr-plugin-sc.postinst	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/vdr-plugin-sc.postinst	2014-04-29 15:11:53.921733466 +0200
@@ -0,0 +1,8 @@
+#! /bin/sh
+set -e
+
+if [ "$1" = 'configure' ]
+then
+    [ -d /etc/vdr/plugins/sc ] || mkdir /etc/vdr/plugins/sc
+    chown vdr:vdr /etc/vdr/plugins/sc
+fi
diff -Naur sc-orgnl/debian/vdr-plugin-sc.postrm sc/debian/vdr-plugin-sc.postrm
--- sc-orgnl/debian/vdr-plugin-sc.postrm	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/vdr-plugin-sc.postrm	2014-04-29 15:11:53.921733466 +0200
@@ -0,0 +1,6 @@
+#! /bin/sh
+
+if [ "$1" = 'purge' ]
+then
+    rm -rf /etc/vdr/plugins/sc
+fi
diff -Naur sc-orgnl/debian/vdr-plugin-sc-seca.install sc/debian/vdr-plugin-sc-seca.install
--- sc-orgnl/debian/vdr-plugin-sc-seca.install	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/vdr-plugin-sc-seca.install	2014-04-29 15:11:53.885733467 +0200
@@ -0,0 +1 @@
+usr/lib/vdr/plugins/libsc-*seca*.so.*
diff -Naur sc-orgnl/debian/vdr-plugin-sc-shl.install sc/debian/vdr-plugin-sc-shl.install
--- sc-orgnl/debian/vdr-plugin-sc-shl.install	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/vdr-plugin-sc-shl.install	2014-04-29 15:11:53.921733466 +0200
@@ -0,0 +1 @@
+usr/lib/vdr/plugins/libsc-*shl*.so.*
diff -Naur sc-orgnl/debian/vdr-plugin-sc-viaccess.install sc/debian/vdr-plugin-sc-viaccess.install
--- sc-orgnl/debian/vdr-plugin-sc-viaccess.install	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/vdr-plugin-sc-viaccess.install	2014-04-29 15:11:53.885733467 +0200
@@ -0,0 +1 @@
+usr/lib/vdr/plugins/libsc-*viaccess*.so.*
diff -Naur sc-orgnl/debian/vdr-plugin-sc-videoguard2.install sc/debian/vdr-plugin-sc-videoguard2.install
--- sc-orgnl/debian/vdr-plugin-sc-videoguard2.install	1970-01-01 01:00:00.000000000 +0100
+++ sc/debian/vdr-plugin-sc-videoguard2.install	2014-04-29 15:11:53.921733466 +0200
@@ -0,0 +1 @@
+usr/lib/vdr/plugins/libsc-*videoguard2*.so.*
diff -Naur sc-orgnl/device.c sc/device.c
--- sc-orgnl/device.c	2014-04-29 15:09:34.261738562 +0200
+++ sc/device.c	2014-04-29 15:11:30.029734338 +0200
@@ -52,7 +52,7 @@
   SetDescription("TS buffer on device %d", CardIndex);
   f=File; size=Size; cardIndex=CardIndex; decsa=DeCsa;
   delivered=false;
-  ringBuffer=new cRingBufferLinear(Size,TS_SIZE,true,"FFdecsa-TS");
+  ringBuffer=new cRingBufferLinear(Size,TS_SIZE,true,RINGBUFFERNAME);
   ringBuffer->SetTimeouts(100,100);
   if(decsa) decsa->SetActive(true);
   SetActive(ScActive);
@@ -357,7 +357,7 @@
   *vdr_nci=0; *vdr_ud=vdr_save_ud;
 
   int i, found=0;
-  for(i=0; i<MAXDVBDEVICES; i++) {
+  for(i=0; i<MAXDEVICES; i++) {
     if(UseDevice(NextCardIndex())) {
       char name[128];
       cScDevices::DvbName(DEV_DVB_FRONTEND,i,0,name,sizeof(name));
@@ -382,7 +382,7 @@
       }
     else NextCardIndex(1);
     }
-  NextCardIndex(MAXDVBDEVICES-i);
+  NextCardIndex(MAXDEVICES-i);
   if(found>0) PRINTF(L_GEN_INFO,"captured %d video device%s",found,found>1 ? "s" : "");
   else PRINTF(L_GEN_INFO,"no DVB device captured");
   return found>0;
@@ -411,7 +411,7 @@
 
 void cScDevices::SetForceBudget(int n)
 {
-   if(n>=0 && n<MAXDVBDEVICES) budget|=(1<<n);
+   if(n>=0 && n<MAXDEVICES) budget|=(1<<n);
 }
 
 bool cScDevices::ForceBudget(int n)
diff -Naur sc-orgnl/device.h sc/device.h
--- sc-orgnl/device.h	2014-04-29 15:09:34.169738565 +0200
+++ sc/device.h	2014-04-29 15:11:14.009734922 +0200
@@ -25,6 +25,12 @@
 #include <vdr/thread.h>
 #include "misc.h"
 
+#ifndef LIBDVBCSA
+#define RINGBUFFERNAME "FFdecsa-TS"
+#else
+#define RINGBUFFERNAME "libdvbcsa-ts"
+#endif
+
 class cDeCSA;
 
 // ----------------------------------------------------------------
diff -Naur sc-orgnl/device-tmpl.c sc/device-tmpl.c
--- sc-orgnl/device-tmpl.c	2014-04-29 15:09:34.169738565 +0200
+++ sc/device-tmpl.c	2014-04-29 15:10:57.525735524 +0200
@@ -41,7 +41,6 @@
 #endif //!SASC
 protected:
 #ifndef SASC
-  virtual bool Ready(void);
   virtual bool SetPid(cPidHandle *Handle, int Type, bool On);
   virtual bool SetChannelDevice(const cChannel *Channel, bool LiveView);
   virtual bool OpenDvr(void);
@@ -164,12 +163,6 @@
   return cam || hwciadapter;
 }
 
-bool SCDEVICE::Ready(void)
-{
-  return (cam         ? cam->Ready():true) &&
-         (hwciadapter ? hwciadapter->Ready():true);
-}
-
 bool SCDEVICE::SetPid(cPidHandle *Handle, int Type, bool On)
 {
   if(cam) cam->SetPid(Type,Handle->pid,On);
diff -Naur sc-orgnl/Makefile sc/Makefile
--- sc-orgnl/Makefile	2014-04-29 15:09:34.253738562 +0200
+++ sc/Makefile	2014-04-29 15:11:14.009734922 +0200
@@ -1,29 +1,15 @@
 #
-# Softcam plugin to VDR
+# Makefile for a Video Disk Recorder plugin
 #
-# This code is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License
-# as published by the Free Software Foundation; either version 2
-# of the License, or (at your option) any later version.
-#
-# This code is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-# Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+# $Id$
 
 # The official name of this plugin.
 # This name will be used in the '-P...' option of VDR to load the plugin.
 # By default the main source file also carries this name.
-#
-PLUGIN = sc
 
-### The version number of this plugin
+PLUGIN = sc
 
+### The version number of this plugin (taken from the main source file):
 DISTFILE = .distvers
 HGARCHIVE = .hg_archival.txt
 RELEASE := $(shell grep 'define SC_RELEASE' version.h | awk '{ print $$3 }' | sed -e 's/[";]//g')
@@ -38,212 +24,125 @@
                    fi)
 VERSION := $(RELEASE)-$(SUBREL)
 SCAPIVERS := $(shell sed -ne '/define SCAPIVERS/ s/^.[a-zA-Z ]*\([0-9]*\).*$$/\1/p' version.h)
-
 ### The directory environment:
 
-VDRDIR = ../../..
-LIBDIR = ../../lib
-SYSDIR = ./systems
-PREDIR = ./systems-pre
-TMPDIR = /tmp
-
-### The C++ compiler and options:
-
-CXX      ?= g++
-CXXFLAGS ?= -O2 -g -Wall -Woverloaded-virtual
-
-### Includes and Defines
-
-INCLUDES      = -I$(VDRDIR)/include
-DEFINES       = -DPLUGIN_NAME_I18N='"$(PLUGIN)"'
-SHAREDDEFINES = -DAPIVERSNUM=$(APIVERSNUM) -D_GNU_SOURCE
-LIBS          = -lcrypto
-SHAREDLIBS    =
+# Use package data if installed...otherwise assume we're under the VDR source directory:
+PKGCFG = $(if $(VDRDIR),$(shell pkg-config --variable=$(1) $(VDRDIR)/vdr.pc),$(shell pkg-config --variable=$(1) vdr || pkg-config --variable=$(1) ../../../vdr.pc))
+LIBDIR = $(call PKGCFG,libdir)
+LOCDIR = $(call PKGCFG,locdir)
+PLGCFG = $(call PKGCFG,plgcfg)
+#
+
+SYSDIR  = ./systems
+PREDIR  = ./systems-pre
+LIBS   := -lcrypto
+TMPDIR ?= /tmp
+
+### The compiler options:
+
+export CFLAGS   = $(call PKGCFG,cflags)
+export CXXFLAGS = $(call PKGCFG,cxxflags)
+export SCAPIVERS
+export APIVERSION
+
+### The version number of VDR's plugin API:
+
+APIVERSION = $(call PKGCFG,apiversion)
 
 ### Allow user defined options to overwrite defaults:
 
--include $(VDRDIR)/Make.global
--include $(VDRDIR)/Make.config
--include Make.config
-
-# we need this ATM because of the helper.h macros...
-CXXFLAGS += -fno-strict-aliasing
-
-### The version number of VDR (taken from VDR's "config.h"):
-
-VDRVERSION := $(shell sed -ne '/define VDRVERSION/ s/^.*"\(.*\)".*$$/\1/p' $(VDRDIR)/include/vdr/config.h)
-APIVERSION := $(shell sed -ne '/define APIVERSION/ s/^.*"\(.*\)".*$$/\1/p' $(VDRDIR)/include/vdr/config.h)
-ifeq ($(strip $(APIVERSION)),)
-   APIVERSION = $(VDRVERSION)
-endif
-VDRVERSNUM := $(shell sed -ne '/define VDRVERSNUM/ s/^.[a-zA-Z ]*\([0-9]*\) .*$$/\1/p' $(VDRDIR)/include/vdr/config.h)
-APIVERSNUM := $(shell sed -ne '/define APIVERSNUM/ s/^.[a-zA-Z ]*\([0-9]*\) .*$$/\1/p' $(VDRDIR)/include/vdr/config.h)
-ifeq ($(strip $(APIVERSNUM)),)
-   APIVERSNUM = $(VDRVERSNUM)
-endif
+-include $(PLGCFG)
 
-### The object files (add further files here):
+### The name of the distribution archive:
 
-OBJS = $(PLUGIN).o data.o filter.o system.o misc.o cam.o device.o version.o \
-       smartcard.o network.o crypto.o system-common.o parse.o log.o \
-       override.o
+ARCHIVE = $(PLUGIN)-$(VERSION)
+PACKAGE = vdr-$(ARCHIVE)
 
-### Internationalization (I18N):
+### The name of the shared object file:
 
-PODIR     = po
-I18Npot   = $(PODIR)/$(PLUGIN).pot
-I18Nmo    = vdr-$(PLUGIN).mo
-I18Nmsgs  = $(addprefix $(LOCALEDIR)/,$(addsuffix /LC_MESSAGES/$(I18Nmo),$(notdir $(foreach file, $(wildcard $(PODIR)/*.po), $(basename $(file))))))
-LOCALEDIR = $(VDRDIR)/locale
-
-### VDR version dependant
-
-# test VDR version
-BYVERS = $(strip $(shell if test $(APIVERSNUM) -ge 010703; then echo "*"; fi))
-# test if PlayTsVideo() exists (e.g. TSplay patch)
-BYTSPL = $(strip $(shell grep -l 'PlayTsVideo' $(VDRDIR)/include/vdr/device.h))
+SOFILE = libvdr-$(PLUGIN).so
 
-ifneq ($(BYVERS)$(BYTSPL),)
-  SHAREDDEFINES += -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE
-endif
+### Includes and Defines (add further entries here):
 
-#
-# generic stuff
-#
+INCLUDES +=
 
-# smartcard default port (dropped)
-ifdef DEFAULT_PORT
-  $(error DEFAULT_PORT support was removed, use cardslot.conf)
-endif
+DEFINES += -DPLUGIN_NAME_I18N='"$(PLUGIN)"'
 
-ifdef WITH_PCSC
-  DEFINES  += -DWITH_PCSC
-  LIBS     += -lpcsclite
-endif
+### The object files (add further files here):
 
-HAVE_SD := $(wildcard ../dvbsddevice/dvbsddevice.c)
-ifneq ($(strip $(HAVE_SD)),)
-  DEFINES += -DWITH_SDDVB
-  DEVPLUGTARGETS += $(LIBDIR)/libsc-dvbsddevice-$(SCAPIVERS).so.$(APIVERSION)
-endif
-DEVPLUGOBJS += device-sd.o
-HAVE_HD := $(wildcard ../dvbhddevice/dvbhddevice.c)
-ifneq ($(strip $(HAVE_HD)),)
-  HDVERS := $(shell sed -ne '/*VERSION/ s/^.*=.*"\(.*\)".*$$/\1/p' ../dvbhddevice/dvbhddevice.c)
-  ifeq ($(findstring dag,$(HDVERS)),)
-    DEFINES += -DWITH_HDDVB
-    DEVPLUGTARGETS += $(LIBDIR)/libsc-dvbhddevice-$(SCAPIVERS).so.$(APIVERSION)
-  endif
-endif
-DEVPLUGOBJS += device-hd.o
+OBJS = $(PLUGIN).o data.o filter.o system.o misc.o cam.o device.o version.o \
+       smartcard.o network.o crypto.o system-common.o parse.o log.o \
+       override.o
 
 # max number of CAIDs per slot
-MAXCAID := $(shell sed -ne '/define MAXCASYSTEMIDS/ s/^.[a-zA-Z ]*\([0-9]*\).*$$/\1/p' $(VDRDIR)/ci.c)
-ifneq ($(strip $(MAXCAID)),)
-  DEFINES += -DVDR_MAXCAID=$(MAXCAID)
-endif
+MAXCAID := 64
 
+ifndef LIBDVBCSA
 # FFdeCSA
-CPUOPT     ?= pentium
-PARALLEL   ?= PARALLEL_32_INT
-CSAFLAGS   ?= -Wall -fPIC -g -O3 -mmmx -fomit-frame-pointer -fexpensive-optimizations -funroll-loops
+PARALLEL   ?= PARALLEL_128_SSE2
+CSAFLAGS   ?= -fexpensive-optimizations -fomit-frame-pointer -funroll-loops -O3 -mmmx -msse -msse2 -msse3
 FFDECSADIR  = FFdecsa
 FFDECSA     = $(FFDECSADIR)/FFdecsa.o
-FFDECSATEST = $(FFDECSADIR)/FFdecsa_test.done
-
-# SASC
-ifdef SASC
-DEFINES += -DSASC
-FFDECSA =
-FFDECSATEST =
-endif
-
-# export for system makefiles
-export SCAPIVERS
-export APIVERSION
-export INCLUDES
-export SHAREDDEFINES
-export SHAREDLIBS
-export CXX
-export CXXFLAGS
-
-### Targets:
-
-ifdef STATIC
-BUILDTARGETS = $(LIBDIR)/libvdr-$(PLUGIN).a
-SHAREDDEFINES += -DSTATICBUILD
+DECSALIB    = $(FFDECSA)
 else
-BUILDTARGETS = $(LIBDIR)/libvdr-$(PLUGIN).so.$(APIVERSION) systems-pre $(DEVPLUGTARGETS)
+# libdvbcsa
+DECSALIB = -ldvbcsa
+DEFINES += -DLIBDVBCSA
 endif
-BUILDTARGETS += $(FFDECSATEST) systems i18n
 
-all: $(BUILDTARGETS)
-.PHONY: i18n systems systems-pre contrib clean clean-core clean-systems clean-pre dist srcdist
+### The main target:
 
-# Dependencies:
+all: $(SOFILE) systems-pre systems i18n
 
-MAKEDEP = g++ -MM -MG
-DEPFILE = .dependencies
-DEPFILES = $(subst i18n.c,,$(subst version.c,,$(OBJS:%.o=%.c)))
-$(DEPFILE): $(DEPFILES) $(wildcard *.h)
-	@$(MAKEDEP) $(DEFINES) $(SHAREDDEFINES) $(INCLUDES) $(DEPFILES) > $@
-
--include $(DEPFILE)
 
-# Rules
+### Implicit rules:
 
 %.o: %.c
-	$(CXX) $(CXXFLAGS) -c $(DEFINES) $(SHAREDDEFINES) $(INCLUDES) $<
+	$(CXX) $(CXXFLAGS) -c $(DEFINES) $(INCLUDES) -o $@ $<
 
-libvdr-$(PLUGIN).so: $(OBJS) $(FFDECSA)
-	$(CXX) $(CXXFLAGS) -shared $(OBJS) $(FFDECSA) $(LIBS) $(SHAREDLIBS) -o $@
+### Dependencies:
 
-$(LIBDIR)/libvdr-$(PLUGIN).so.$(APIVERSION): libvdr-$(PLUGIN).so
-	@cp -p $< $@
-
-$(LIBDIR)/libvdr-$(PLUGIN).a: $(OBJS)
-	$(AR) r $@ $(OBJS)
-
-libsc-dvbsddevice.so: device-sd.o
-	$(CXX) $(CXXFLAGS) -shared $< $(SHAREDLIBS) -o $@
+MAKEDEP = $(CXX) -MM -MG
+DEPFILES = $(subst i18n.c,,$(subst version.c,,$(OBJS:%.o=%.c)))
+$(DEPFILE): $(DEPFILES) $(wildcard *.h)
+	@$(MAKEDEP) $(CXXFLAGS) $(DEFINES) $(INCLUDES) $(OBJS:%.o=%.c) > $@
 
-$(LIBDIR)/libsc-dvbsddevice-$(SCAPIVERS).so.$(APIVERSION): libsc-dvbsddevice.so
-	@cp -p $< $@
+-include $(DEPFILE)
 
-libsc-dvbhddevice.so: device-hd.o
-	$(CXX) $(CXXFLAGS) -shared $< $(SHAREDLIBS) -o $@
+### Internationalization (I18N):
 
-$(LIBDIR)/libsc-dvbhddevice-$(SCAPIVERS).so.$(APIVERSION): libsc-dvbhddevice.so
-	@cp -p $< $@
+PODIR     = po
+I18Npo    = $(wildcard $(PODIR)/*.po)
+I18Nmo    = $(addsuffix .mo, $(foreach file, $(I18Npo), $(basename $(file))))
+I18Nmsgs  = $(addprefix $(DESTDIR)$(LOCDIR)/, $(addsuffix /LC_MESSAGES/vdr-$(PLUGIN).mo, $(notdir $(foreach file, $(I18Npo), $(basename $(file))))))
+I18Npot   = $(PODIR)/$(PLUGIN).pot
 
-$(FFDECSA) $(FFDECSATEST): $(FFDECSADIR)/*.c $(FFDECSADIR)/*.h
-	@$(MAKE) COMPILER="$(CXX)" FLAGS="$(CSAFLAGS) -march=$(CPUOPT)" PARALLEL_MODE=$(PARALLEL) -C $(FFDECSADIR) all
+%.mo: %.po
+	msgfmt -c -o $@ $<
 
-$(I18Npot): $(shell grep -rl '\(tr\|trNOOP\)(\".*\")' *.c $(SYSDIR))
-	xgettext -C -cTRANSLATORS --no-wrap --no-location -k -ktr -ktrNOOP --package-name=VDR-SC --package-version=$(VERSION) --msgid-bugs-address='<noone@nowhere.org>' -o $@ `ls $^`
+$(I18Npot): $(wildcard *.c)
+	xgettext -C -cTRANSLATORS --no-wrap --no-location -k -ktr -ktrNOOP --package-name=vdr-$(PLUGIN) --package-version=$(VERSION) --msgid-bugs-address='<see README>' -o $@ `ls $^`
 
 %.po: $(I18Npot)
-	msgmerge -U --no-wrap --no-location --no-fuzzy-matching --backup=none -q $@ $<
+	msgmerge -U --no-wrap --no-location --backup=none -q -N $@ $<
 	@touch $@
 
-%.mo: %.po
-	msgfmt -c -o $@ $<
+$(I18Nmsgs): $(DESTDIR)$(LOCDIR)/%/LC_MESSAGES/vdr-$(PLUGIN).mo: $(PODIR)/%.mo
+	install -D -m644 $< $@
 
-$(I18Nmsgs): $(LOCALEDIR)/%/LC_MESSAGES/$(I18Nmo): $(PODIR)/%.mo
-	@mkdir -p $(dir $@)
-	cp $< $@
+.PHONY: i18n systems systems-pre
+i18n: $(I18Nmo) $(I18Npot)
 
-i18n: $(I18Nmsgs)
-
-version.c: FORCE
+version.c:
 	@echo >$@.new "/* generated file, do not edit */"; \
-	 echo >>$@.new 'const char *ScVersion =' '"'$(VERSION)'";'; \
-	 diff $@.new $@ >$@.diff 2>&1; \
-	 if test -s $@.diff; then mv -f $@.new $@; fi; \
-	 rm -f $@.new $@.diff;
+		echo >>$@.new 'const char *ScVersion =' '"'$(VERSION)'";'; \
+		diff $@.new $@ >$@.diff 2>&1; \
+		if test -s $@.diff; then mv -f $@.new $@; fi; \
+		rm -f $@.new $@.diff;
 
 systems:
-	@for i in `ls -A -I ".*" $(SYSDIR)`; do $(MAKE) -f ../../Makefile.system -C "$(SYSDIR)/$$i" all || exit 1; done
+	@mkdir lib
+	@for i in `ls -A -I ".*" $(SYSDIR)`; do  $(MAKE) LIBDIR=../../lib -f ../../Makefile.system -C "$(SYSDIR)/$$i" all || exit 1; done
 
 systems-pre:
 	@for i in `ls -A -I ".*" $(PREDIR) | grep -- '-$(SCAPIVERS).so.$(APIVERSION)$$'`; do cp -p "$(PREDIR)/$$i" "$(LIBDIR)"; done
@@ -251,45 +150,36 @@
 contrib:
 	@$(MAKE) -C contrib all
 
-clean-systems:
-	@for i in `ls -A -I ".*" $(SYSDIR)`; do $(MAKE) -f ../../Makefile.system -C "$(SYSDIR)/$$i" clean; done
+install-i18n: $(I18Nmsgs)
+
+### Targets:
+
+$(SOFILE): $(OBJS) $(DECSALIB)
+	$(CXX) $(CXXFLAGS) $(LDFLAGS) -shared $(OBJS) $(DECSALIB) $(LIBS) -o $@
 
-clean-core:
-	@$(MAKE) -C testing clean
-	@$(MAKE) -C contrib clean
-	@if test -d $(FFDECSADIR); then $(MAKE) -C $(FFDECSADIR) clean; fi
-	@-rm -f $(LIBDIR)/libsc-*-$(SCAPIVERS).so.$(APIVERSION)
-	@-rm -f $(LIBDIR)/libvdr-$(PLUGIN).a $(LIBDIR)/libsc-*.a
-	@-rm -f $(OBJS) $(DEVPLUGOBJS) $(DEPFILE) version.c *.so *.tar.gz core* *~
-	@-rm -f $(PODIR)/*.mo
-
-clean-pre:
-	@-find "$(PREDIR)" -type f -not -name ".empty" -not -iname "*-$(SCAPIVERS).so.*" | xargs rm -f
-
-clean: clean-core clean-systems
-
-dist: ARCHIVE := $(PLUGIN)-$(RELEASE)
-dist: clean-core
-	@for i in `ls -A -I ".*" $(SYSDIR)`; do $(MAKE) -f ../../Makefile.system -C "$(SYSDIR)/$$i" dist; done
+ifndef LIBDVBCSA
+$(FFDECSA): $(FFDECSADIR)/*.c $(FFDECSADIR)/*.h
+	@$(MAKE) COMPILER="$(CXX)" FLAGS="$(CXXFLAGS) $(CSAFLAGS)" PARALLEL_MODE=$(PARALLEL) -C $(FFDECSADIR) all
+endif
+
+install-lib: $(SOFILE)
+	install -D $^ $(DESTDIR)$(LIBDIR)/$^.$(APIVERSION)
+	install -D lib/* $(DESTDIR)$(LIBDIR)/
+
+install: install-lib install-i18n
+
+dist: $(I18Npo) clean
 	@-rm -rf $(TMPDIR)/$(ARCHIVE)
 	@mkdir $(TMPDIR)/$(ARCHIVE)
 	@cp -a * $(TMPDIR)/$(ARCHIVE)
-	@echo -n "release" >$(TMPDIR)/$(ARCHIVE)/$(DISTFILE)
-	@path="$(TMPDIR)/$(ARCHIVE)/$(notdir $(SYSDIR))";\
-	 for i in `ls -A -I ".*" $$path`; do if [ -f "$$path/$$i/nonpublic.mk" ]; then rm -rf "$$path/$$i"; fi; if [ -f "$$path/$$i/nonpublic.sh" ]; then (cd $$path/$$i ; source ./nonpublic.sh ; rm ./nonpublic.sh); fi; done
-	@strip --strip-unneeded --preserve-dates $(TMPDIR)/$(ARCHIVE)/$(notdir $(PREDIR))/* || true
-	@tar czf vdr-$(ARCHIVE).tar.gz -C $(TMPDIR) $(ARCHIVE)
+	@tar czf $(PACKAGE).tgz -C $(TMPDIR) $(ARCHIVE)
 	@-rm -rf $(TMPDIR)/$(ARCHIVE)
-	@echo Distribution package created as vdr-$(ARCHIVE).tar.gz
+	@echo Distribution package created as $(PACKAGE).tgz
 
-copy: ARCHIVE := $(PLUGIN)-$(VERSION)
-copy: clean clean-pre
-	@-rm -rf $(TMPDIR)/$(ARCHIVE)
-	@mkdir $(TMPDIR)/$(ARCHIVE)
-	@cp -a .hgtags .hgignore * $(TMPDIR)/$(ARCHIVE)
-	@echo -n $(SUBREL) | sed -e 's/HG-/CP-/' >$(TMPDIR)/$(ARCHIVE)/$(DISTFILE)
-	@tar czf vdr-$(ARCHIVE).tar.gz -C $(TMPDIR) $(ARCHIVE)
-	@-rm -rf $(TMPDIR)/$(ARCHIVE)
-	@echo Full copy package created as vdr-$(ARCHIVE).tar.gz
+clean-systems:
+	@for i in `ls -A -I ".*" $(SYSDIR)`; do $(MAKE) -f ../../Makefile.system -C "$(SYSDIR)/$$i" clean; done
 
-FORCE:
+clean: clean-systems
+	@-rm -f $(PODIR)/*.mo $(PODIR)/*.pot
+	@-rm -f $(OBJS) $(DEPFILE) *.so *.tgz core* *~
+	@-rm -rf lib
